<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nand2tetris_week3</title>
    <url>/2019/11/17/nand2tetris-week3/</url>
    <content><![CDATA[<p>之前的两周都是输入对应着输出，没有将时间维度考虑进来。引入时间维度相关的两个问题，</p>
<ol>
<li>在时间维度上复用某个硬件，即多次重复计算采用同样的硬件</li>
<li>sum类的问题，累加起来的值的保存问题<br>本周聚焦的是计算机如何线性时间执行任务，引入sequenctial logic 的概念。<h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3>物理时间对应到计算机中是利用clock, 将物理时间分成一小段一小段相等的time unit. clock是由某种振荡器(oscillator) 构成，就是会在两个值之间来回跳转，每次循环就看成一个时间单元(time unit), 每个时间单元里变换输入就可以在不同的时间段得到不同的输出。<h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4>如图所示，实际生活中电压延迟，经过门电路计算造成的延迟等会造成每个时间单元的前部分有延迟；<img src="/2019/11/17/nand2tetris-week3/F4322002-F783-4454-8E22-EB3CEE6A1DA3.png">
在显示中通过设计扩大时间单元的长度，将延迟包含在内，然后采用每个时间单元结尾时候的状态就可以避免延迟造成的影响。<br>clock的目的就是为了保证稳定性，持续输入时由于有延迟的影响，需要在特定时间采用值。<h3 id="combinational-logic-vs-sequential-logic"><a href="#combinational-logic-vs-sequential-logic" class="headerlink" title="combinational logic vs sequential logic"></a>combinational logic vs sequential logic</h3>combinational logic 就是在一个时间单元里的一个输入到输出<br>out[t]  =  f(in[t])<br>但是sequential logic是多个时间单元<br>out[t] = f(in[t-1])</li>
</ol>
<p>在sequential logic里可以将之前计算的结果保留在一个硬件里，之后计算的结果覆盖到这个硬件里就可以用来解决上面提到的累加问题的状态保存。<br><a id="more"></a></p>
<h3 id="flip-flop-gate"><a href="#flip-flop-gate" class="headerlink" title="flip-flop gate"></a>flip-flop gate</h3><p>计算机中最基础的sequential logic 是由flip-flop 这个chip提供的。在本课程中使用了一个data-flip-flop(DFF) 是一个变体。<br><img src="/2019/11/17/nand2tetris-week3/D0D6357D-C816-40A3-9EA9-3E7740F06C59.png"></p>
<p><strong>out(t) = in(t–1)</strong><br>三角符号表示这是一个 sequential的chip和之前的combinational chip区别开。为什么叫flip-flop是因为它能根据它的输入 在0 和 1 之间来回变化，它的作用就是记住上一个时间单元的input值。它利用了clock 传进来的电信号和input的值保存了一个时间单元的input值。关于它的实现没有细讲，是可以通过nand来实现的大概是：</p>
<ol>
<li>利用loop实现信号的保存</li>
<li>将clock信号引入保存一个时间单元的信号<br>教授的意思是实现虽然优雅但复杂，希望我们只理解到combinational logic是及时的而sequential logic是跨越时间的。在这门课中DFF是作为一个基础chip来使用就和NAND一样。</li>
</ol>
<p><em>ps: 项目中的所有combinational chip都可以从NAND 得到，而所有的sequential chip 都可以从DFF chip 和 combinational chip构成</em></p>
<h3 id="register-1-bit"><a href="#register-1-bit" class="headerlink" title="register 1-bit"></a>register 1-bit</h3><p>DFF只能记一个时间单元的input，现在想要长久记住一个值。下面是它的实现<br><img src="/2019/11/17/nand2tetris-week3/8A013B0F-42D3-4DA9-B6E7-2CA880966403.png"></p>
<p>if  load(t-1) =1  then out(t) = in(t-1)<br>else out(t) = out(t-1)<br><img src="/2019/11/17/nand2tetris-week3/341FC35F-2B05-4671-97A6-6046E1D077FA.png"></p>
<p>下表是随着load变化值的变化，mux是代表mux的输出，即DFF的输入。图上的in相当于mux chip 里的b， out连过来的相当于a. ps: 为什么不能立刻访问DFF里的值猜测也是延迟原因造成的。<br>当load是0的时候，相当于DFF的输入是它的输出，所以就保存了这个值。</p>
<img src="/2019/11/17/nand2tetris-week3/D04E7B71-E490-422B-BE5A-989DEEAA5DC3.png">
<h3 id="memory-units"><a href="#memory-units" class="headerlink" title="memory units"></a>memory units</h3><p>memory 包含 RAM( random access memory ) 和 ROM(read only memory) （开机程序通常储存在这里）一个是临时的一个是永久的。<br>另外还有flash memory 同样是永久存储而且是read and write 皆可。<br>RAM里有data和instructions </p>
<h4 id="w-bit-register"><a href="#w-bit-register" class="headerlink" title="w-bit register"></a>w-bit register</h4><img src="/2019/11/17/nand2tetris-week3/EF0AB89C-C895-4859-B175-4C024E1F8FD8.png">
<p>利用上面的1-bit register 可以实现 w-bit register , 一些电脑是16, 32, 64 位，多少位的操作系统一般就是多少位的寄存器的宽。本门课实现的hack computer是16位的。</p>
<h5 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h5><p>out 连接的就是寄存器的state值，所以任何时间点我们想要知道寄存器的state，就读取out的值就可以了</p>
<h5 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h5><p>set in = x<br>set load = 1<br>寄存器的state 变成了x 但是这里是有延迟的，所以下个时间单元里才是我们要读取的值。</p>
<p>模拟器载入内置chip DRegister<br><img src="/2019/11/17/nand2tetris-week3/A647BF4A-3CFB-4CE8-A8A9-AAF888FE767B.png"></p>
<p>闹钟可以模拟tick tock ，点两下就是一个cycle. 右下角是register的内部state，可以理解成上面那个DFF的input值，这个state需要在每个cycle结束后和out同步 ~  tick 一下就是一个时间单元的第一个阶段并且触发了一个时间单元的第二个部分。tock一下就是第二个时间单元的开始。<br>想象成tick tock 的两个时间点都是瞬间执行完，并且DFF的值只有在tock的时间点是获取到的是上个tock的值或者一直保存的原先的out值</p>
<h3 id="RAM-unit"><a href="#RAM-unit" class="headerlink" title="RAM unit"></a>RAM unit</h3><img src="/2019/11/17/nand2tetris-week3/6E620105-93D3-4C74-8B33-F5368EA5849A.png">
<p>RAM 抽象来看就是由n个可以寻址(addressable) 的registers 构成。<br>在任意给定的时间点，只有<strong>一个</strong>register被选中。（实现的时候是input连接到所有register上通过mux dmux来实现被选中）<br>有n个地址需要则需要 log2 n 的数量的位数去表达。<br>比如八个地址就要3位bit去表示地址。<br>如果load设置为1，则选中的寄存器就被赋值，并且这个值在下个cycle中可以读取，如果是0则读选中的寄存器之前存的值。<br>RAM可以所以选取任意一个register进行存储，只要给个address地址就可以做到读取和写入，所以叫random access memory. 不过RAM有多少个register，寻找到特定地址的register的时间都是几乎一样的。<br>作业中的RAM8就是由8个寄存器构成，RAM64则是由8个RAM8构成，实现的时候，根据address 可以先找到具体的RAM接着再找到RAM里面对应的寄存器。</p>
<h4 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h4><p>set address = i<br>读取register i 的out </p>
<h4 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h4><p>set address = i<br>set in = v<br>set load = 1<br>寄存器i 的state 就变成了 v,<br>下个cycle RAM的out 就变成了v.<br>按照课程的意思就是这个RAM的out是某个寄存器的值。</p>
<p>ps: 可以利用内置的RAM8 chip进行内部状态查看</p>
<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>就好像菜谱有一堆步骤一样，你按照菜谱一步一步做饭；但是你每次不一定是从菜谱的第一步开始。比如前几部是刷锅啥的o(╯□╰)o。。<br>Counter也类似，它支持累加，支持设置初始值，也支持重置。对应到程序执行中就是找到初始指令的位置，执行初始指令，再拿到下一条指令再执行。</p>
<img src="/2019/11/17/nand2tetris-week3/0383D8C0-9BA6-4285-873F-827EC4EE3491.png">
<p>Counter的逻辑<br><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	* A 16-bit counter with load and reset control bits. </span></span><br><span class="line"><span class="comment">	* if reset(t) out(t+1) = 0 </span></span><br><span class="line"><span class="comment">	* else if load(t) out(t+1) = in(t) </span></span><br><span class="line"><span class="comment">	* else if inc(t) out(t+1) = out(t) + 1 (integer addition) </span></span><br><span class="line"><span class="comment">	* else out(t+1) = out(t) </span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>本周项目中分为a b 两个文件夹，原因是模拟器是按照文件夹读取chip的，这样可以保证在b文件夹中的RAM16k RAM512 之类的有很多register的RAM性能更好。（还是因为我们自己构建的low level 的组件可能存在性能问题👀）<br><a href="https://github.com/yiuyiu/nand2Tetris/tree/master/03" target="_blank" rel="noopener">nand2Tetris/03 at master · yiuyiu/nand2Tetris · GitHub</a></p>
<p><strong>Bit</strong> 主要是注意DFF组件不像一般的combinational chip，它的out是可以连接到in的。<br><strong>Register</strong> 比较简单，多个Bit合并而成<br><strong> RAM8</strong>  利用DMux 将3位address映射到8个register上。之后8个register的结果利用Mux以及3位的address选择其中一个。在设计chip的时候需要跳出常规思维，信号分成多少股它的速度都是一样的，可能通常需要进行多个chip计算但是只挑选其中一个作为结果。<br><strong>RAM64</strong> address是6位了，利用前三位可以映射到不同的RAM上，后三位再在RAM里选择特定的寄存器。<br><strong>RAM512</strong> 以及 <strong>RAM4K</strong> 以及 <strong>RAM16K</strong> 同理。<br><strong>PC</strong> computer counter 主要难点还是在combinational的逻辑上，要实现三层if嵌套。truth table不复杂的情况下可以先列出再从中寻找规律。</p>
]]></content>
      <categories>
        <category>computer organization</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris第二周--布尔算术和ALU</title>
    <url>/2019/11/11/nand2tetris_week2/</url>
    <content><![CDATA[<h3 id="整数的二进制表达"><a href="#整数的二进制表达" class="headerlink" title="整数的二进制表达"></a>整数的二进制表达</h3><p>通过组合不同数量的1和0可以产生不同种的结果，比如两个1,0 数结合可以产生4个不同的结果，11,10,01,00. 进而可以将其映射到不同的表示提示，可以用其来表示十进制的数字分别对应3,2,1,0<br>k个bit能够表示的数的上限为2*k - 1，可以利用等比数列求和得证。ps: 在计算机中，每次分配的内存通常都是固定位数的bit.</p>
<h4 id="从二进制到十进制"><a href="#从二进制到十进制" class="headerlink" title="从二进制到十进制"></a>从二进制到十进制</h4><p>64 十进制的数是6<em>10 + 4 ，进而二进制的数也可以类似用每个位置上对应的指数值乘后再进行相加<br>1010  即 1</em>2^3+0<em>2^2+1</em>2^1+0*2^0 = 12</p>
<h4 id="从十进制到二进制"><a href="#从十进制到二进制" class="headerlink" title="从十进制到二进制"></a>从十进制到二进制</h4><p>和上个步骤相反，比如99，可以拆分成2进制的相加为<br>64+32+2+1 则可得出为  1100011<br><a id="more"></a></p>
<h3 id="二进制数相加"><a href="#二进制数相加" class="headerlink" title="二进制数相加"></a>二进制数相加</h3><p>加减通过硬件可以实现，乘除比较复杂通过软件来实现。<br>通关观察十进制相加，二进制相加，也是相应位数相加且二进制相加一样存在进位(carry). 由于计算机中有bit数限制，相加超出范围的部分则舍去。<br>课程中用了三个chip来层层递进实现相加。<br><strong>half-adder</strong>: 两个bit位相加，产生一个out和一个进位，只存在最右边的两个bit相加。<br><strong>full-adder</strong>: 两个bit位和一个进位bit相加，产生一个out和一个进位，除了最右边两个bit相加其他bit位相加都如此。<br><strong>adder</strong>: 将上面两个结合起来就是两个二进制相加的chip.<br>具体实现和第一周的chip类似，观察true table可以设计出内部的chip结构。</p>
<h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><p>将二进制数的第一位用来表示符号(signed binary numbers), 1就是代表数是负的，0是正的。有两种表示负数的方法</p>
<h4 id="非补码"><a href="#非补码" class="headerlink" title="非补码"></a>非补码</h4><p> Sign-and-Magnitude (SM) notation<br>符号位，剩下的位数表示大小。<br>除第一位表示符号，剩下的bit位表示实际数，比如四位就可以表示<code>0 ~ 7</code>,  <code>-0 ~ -7</code>. 0相当于有两种表示方式.表示范围是 -2^(n-1) ~~ +2^(n-1)</p>
<h4 id="complement-representation"><a href="#complement-representation" class="headerlink" title="complement representation"></a>complement representation</h4><p>正数的补码表示对应的负数的十进制表示是 2^n - x. (n是bit的数量，这里的n的数量是正数前面加上0的数量)<br>比如0101表示5，-5的表示就用<code>2^4 - 5 = 11</code>, 11的二进制表示就是1011.所以-5在补码表示中就为1011<br><em>ps: 2 to the n  可以表示  2^n</em></p>
<h4 id="利用补码实现两数相减"><a href="#利用补码实现两数相减" class="headerlink" title="利用补码实现两数相减"></a>利用补码实现两数相减</h4><p>7 - 5 可以表示为 7 + -5, 利用补码表示分别为0111, 1011, 直接相加，溢出的bit位舍去即可得到0010 即 2</p>
<h4 id="为什么利用补码可以做到"><a href="#为什么利用补码可以做到" class="headerlink" title="为什么利用补码可以做到"></a>为什么利用补码可以做到</h4><p>为什么利用补码可以做到相加即相减的结果。<br>利用了一个modular arithmetic系统，通过对数字加1我们可以循环遍历所有模数里的值，溢出了1就从1开始。就好像时钟一样，11点加上3个小时，就变成了2点。模数就是12。1点往前推3个小时，就相当于1+(12-3) = 10.<br>这里的补码也是同理，减去一个数相当于加上（模数➖这个数）<br>参考<a href="https://math.stackexchange.com/questions/1920772/why-twos-complement-works" target="_blank" rel="noopener">https://math.stackexchange.com/questions/1920772/why-twos-complement-works</a><br>以下距离3个bit<br>000 0<br>001 1<br>010 2<br>011 3<br>100 -4<br>101 -3<br>110 -2<br>111 -1<br>超过最大能表示的正数即➕1后就变成了负的最大依次➕1可以不停循环。<br>记住1000… 表示 -2^(n-1)  111…. 表示 -1 </p>
<h5 id="如何用chip获得补码"><a href="#如何用chip获得补码" class="headerlink" title="如何用chip获得补码"></a>如何用chip获得补码</h5><p>2^n - x = 1 + （ (2^n - 1) - x ）<br>其中2^n - 1 就是 1111… , 再减去x<br>11111111 -<br>10101100<br>01010011<br>相当于每一位取反flip下。<br>最后再➕1, 可以从最右边的bit位，直到不需要再进为止。</p>
<h3 id="ALU-arithmetic-logic-unit"><a href="#ALU-arithmetic-logic-unit" class="headerlink" title="ALU (arithmetic logic unit)"></a>ALU (arithmetic logic unit)</h3><p>1945 数学家 John Von Neumann 设计了现代计算的示意图，计算机中的center processing unit里就有ALU.<br>ALU执行算数或者逻辑运算。通过输入两个值，以及执行操作(function) 的control bit(在课程中即下面的zx, nx, zy, ny, f, no可以控制执行不同的方法). 如果是做成一个truth table 就相当于有8列<br>课程中只实现了18种方法，教授们根据他们想要实现的方法反过来推算需要6个control bit. 实际业界可能是由不同的control bit，以及不同的数量的方法，但这是个trade off. 有些方法甚至可以不放在硬件中交由软件根据已有硬件方法去实现。<br>另外zr和ng也是output的一部分，zr会在out等于0时设置为1否则zr设置为0.另外out是负的则ng设为1否则为0.这两个bit的具体作用在以后会说到。<br><img src="/2019/11/11/nand2tetris_week2/DBF9BC7B-72DA-4D5B-BBC1-A9C6A4BEC032.png"><br>[image:E3162B6A-4AF0-457A-B7A5-629FB4510627-27277-00000E14CBC3FA5B/DBF9BC7B-72DA-4D5B-BBC1-A9C6A4BEC032.png]<br>课程中实现的18种方法, z n 可以理解为zeroed negated.<br><em>ps: 课程提供的硬件模拟器可以查看项目附带的内置的ALU.hdl的内部结构（设置不同的control bit, 显示不同的function名字）</em><br><img src="/2019/11/11/nand2tetris_week2/EA08F077-BEA5-44C3-92B5-6C1945F6EB40.png"><br>preset的值都会依次传递给下一个control bit 使用，类似串联的感觉。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>x: 0010  (2)<br>y: 0111  (7)<br>执行y-x操作<br>f: 000111<br>ny 是1 y =1000<br>f是1   x+y = 1010</p>
<blockquote>
<p>疑问？y - x 即 y + (x的补码)   而在上面中是 !(!y + x)<br>补码是数本身取反加1. </p>
</blockquote>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>课程提供的软件如果在当前打开的文件里找不到引用的chip就会从内置的chip里去引用。所以我们引用第一周的chip实际上是从内置chip里去引用的。<br>引用内置的chip的好处是可以排查错误时在最小范围内排查（当然是在内置chip无措的情况下)，还有一点是内置的chip的性能比自己写的好o(╯□╰)o，否则自己写的性能不好的chip层层调用最后可能模拟器就很卡。</p>
<ol>
<li>HalfAdder实现两数相加生成sum和carry. 比较简单观察truth table很容易得出</li>
<li>FullAdder，三数相加生成sum和carry. 利用HalfAdder即可实现</li>
<li>Add16, 两个16bit数相加，就是利用一堆FullAdder“串联”而成。其实有更有效率的做法，由一系列FullAdder而串联的话，每一位相加都需要之前的结果返回，而有个方法叫<a href="https://en.wikipedia.org/wiki/Carry-lookahead_adder" target="_blank" rel="noopener">carry-lookahead-adder</a>, 可以无须等之前的位数相加的结果就可以进行运算。</li>
<li>Inc16, 在16bit上加1, 一开始我妄想用FullAdder，其中一个input就是[…..,1]这种形式，发现不行，在chip的input 和output的右边不能出现这种形式，不过可以出现true或者false 分别代表1和0. 最后就是一堆HalfAdder“串联”</li>
<li>ALU,  ALU本身的输出并不难，主要利用<code>Mux</code>实现了判断。关键判断<code>zr</code>(1 if (out == 0), 0 otherwise) 绞尽脑汁在想怎么把out一个16bit的数转换成一个1和0. 后来想到正数的求反再+1的第一个bit肯定是1，只有0才能保证第一个bit是0.  </li>
</ol>
]]></content>
      <categories>
        <category>computer organization</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
      </tags>
  </entry>
  <entry>
    <title>nand2tetris第一周--布尔运算和逻辑门</title>
    <url>/2019/11/03/nand2tetris_week1/</url>
    <content><![CDATA[<h3 id="布尔值1-0-的操作"><a href="#布尔值1-0-的操作" class="headerlink" title="布尔值1 0 的操作"></a>布尔值1 0 的操作</h3><p><code>and</code> <code>or</code> <code>not</code><br>algebra function  输入是布尔值，主体对其进行各种操作再返回布尔值的过程。<br>两种布尔函数的</p>
<ol>
<li>expression.（就是用各种and or not 组合表示）可以根据交换律，相等律，德·摩根定律 简化。找到一个最简单的表达式等于原表达式的算法是N-P问题很困难。</li>
<li>true table. 利用布尔的取值只有1 0 的特性，输入较少的情况下可以利用true table, 即列出所有结果，观察得出更简单的表达式<br>truth table 如下 表示 <code>f(x,y,z) =( x or y ) and  not(z)</code></li>
</ol>
<img src="/2019/11/03/nand2tetris_week1/99EC1021-6CCA-4843-B624-A824E61380FB.png">
<p>怎么根据truth table如上，得出布尔表达式的公式呢<br>根据结果是1的那行写一个公式使得除了这行是1外，其他行都是0，比如上面那个truth table写出三个，再将这三个公式or操作则得出最终的公式即满足这个truth table.</p>
<p>理论：<br>任何的布尔方程都可以通过not, and , or 表达出来。其中or 可以通过not and 组合表达出来，利用 de morgan law。再简化点NAND操作可以表达出not and or，所有单独利用NAND操作就可以表示出所有的布尔方程。计算机就是由一个一个NAND芯片组成的，当然你也可以用and or 组合，但在现实中，NAND的物理构成比较经济，所以通常采用它。<br><em>NAND的truth table</em><br>a b Nand(a,b)<br>0 0 1<br>0 1 1<br>1 0 1<br>1 1 0<br><a id="more"></a></p>
<h3 id="逻辑门-logic-gate"><a href="#逻辑门-logic-gate" class="headerlink" title="逻辑门 logic gate"></a>逻辑门 logic gate</h3><p>计算机科学范畴内的逻辑门不涉及到硬件那层，即逻辑门的具体电路实现（circuit implementation）由相关的电子工程专业的负责。 可以参考’logic design’或者’digital design’ 类的书。逻辑门的实现有电子的还有生物的，磁力等。逻辑门是一系列布尔方程的抽象。这里涉及到经典的接口interface和实现implement的关系。使用者关心的是接口，是这个逻辑门的作用，是what的方面，实现关注的是how的方面。接口通常只有一种，而实现各异，好的实现可以节省更多的能源，运算更快等。逻辑门分基础逻辑门(elementary gate)(比如Nand,And) 和复合逻辑门 (composite gate)(比如Adder). 在这个课程里可以将NAND看成基础的，其他的都是组合而成。其中Multiplexor<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chip name: Mux</span><br><span class="line">Inputs: a, b, sel</span><br><span class="line">Outputs: out</span><br><span class="line">Function: If sel=0 then out=a else out=b.</span><br></pre></td></tr></table></figure></p>
<p>可以用于将多个输入”序列化“成单条信息。</p>
<h3 id="硬件描述语言-hardware-description-language-HDL"><a href="#硬件描述语言-hardware-description-language-HDL" class="headerlink" title="硬件描述语言 hardware description language (HDL)"></a>硬件描述语言 hardware description language (HDL)</h3><p>现在业界，硬件大多先是在电脑软件上完成设计，利用硬件模拟等软件完成测试，最后再进入硬件制作过程(其实和建筑里的CAD很像，区别就是CAD里不能模拟建筑的一系列测试，但是HDL在硬件模拟软件上可以得出它的功耗，速度等)。这里就涉及到HDL，它也是一种编程语言，且是命令型的。<br>这里以Xor逻辑门举例。具体怎么设计内部需要经验，就和算法一样（课程中的hdl是课程开发的教授在vhdl的基础上开发的方言，功能没有那么复杂，方便快速学习）<br>同一个input连接到不同的接口处是同时的，不管分成几份。</p>
<img src="/2019/11/03/nand2tetris_week1/FC594A86-3296-41BC-B25D-8C1AE36A478B.png">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Xor (exclusive or) gate: If a&lt;&gt;b out=1 else out=0. */</span></span><br><span class="line">CHIP Xor &#123;</span><br><span class="line">	<span class="keyword">IN</span> a, b;</span><br><span class="line">	<span class="keyword">OUT</span> <span class="keyword">out</span>;</span><br><span class="line">	PARTS:</span><br><span class="line">	<span class="keyword">Not</span>(<span class="keyword">in</span>=a, <span class="keyword">out</span>=nota);</span><br><span class="line">	<span class="keyword">Not</span>(<span class="keyword">in</span>=b, <span class="keyword">out</span>=notb);</span><br><span class="line">	<span class="keyword">And</span>(a=a, b=notb, <span class="keyword">out</span>=w1);</span><br><span class="line">	<span class="keyword">And</span>(a=nota, b=b, <span class="keyword">out</span>=w2);</span><br><span class="line">	<span class="keyword">Or</span>(a=w1, b=w2, <span class="keyword">out</span>=<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的nota, notb 可以看成连接到Not chip的电线</p>
<p>代码中这个部分表示当前chip芯片的接口。指出了这个芯片的名字，并且给出了input pin 和 output pin的名字<br><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">CHIP Xor &#123;</span><br><span class="line">	<span class="keyword">IN</span> a, b;</span><br><span class="line">	<span class="keyword">OUT</span> <span class="keyword">out</span>;</span><br></pre></td></tr></table></figure></p>
<p>每条描述都是在描述某个芯片上的输入输出。<br><code>Not</code>, <code>And</code>, <code>Or</code> 等表示已有的逻辑门，gate可以和chip这两个名字互相使用。括号内的是它的输入输出的赋值，习惯性的两个输入一般都命名为a, b这种。</p>
<h3 id="硬件模拟-hardware-simulation"><a href="#硬件模拟-hardware-simulation" class="headerlink" title="硬件模拟 hardware simulation"></a>硬件模拟 hardware simulation</h3><p>利用课程提供的意见模拟软件，可以读取hdl文件，可以手动设置不同的输入输出值观察产生的结果，可以查看到内部芯片内的每个逻辑门的输入输出。和常见的编程软件的debugger很像。另外如果是为了测试的话，可以利用脚本来实现非手动操作。</p>
<h4 id="tst-测试文件"><a href="#tst-测试文件" class="headerlink" title="tst 测试文件"></a>tst 测试文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load Xor.hdl,</span><br><span class="line">output-list a, b, out;</span><br><span class="line">set a 0, set b 0, eval, output;</span><br><span class="line">set a 0, set b 1, eval, output;</span><br><span class="line">set a 1, set b 0, eval, output;</span><br><span class="line">set a 1, set b 1, eval, output;</span><br></pre></td></tr></table></figure>
<p>加载hdl，指定输出格式，之后的每一行分号结尾的都是一系列命令。<br>可以指定将结果输出到某个文件中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output-file Xor.out</span><br></pre></td></tr></table></figure></p>
<p>避免手动对比，可以利用一下的命令会在每条测试文件里的命令执行完和<code>.cmp</code>里的文件对应行数进行比较，出错则抛错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compare-to Xor.cmp</span><br></pre></td></tr></table></figure></p>
<p>其中cmp文件可以是其他方式生成的<code>.out</code>文件，只是将后缀改成<code>cmp</code>即可，比如一些high-level 语言。这个行为叫behavioral simulation (行为模仿) ,个人理解就是和传统的测试用例一个样子，只不过这些测试用例是用其它的方式生成的。</p>
<h3 id="multi-bit-buses"><a href="#multi-bit-buses" class="headerlink" title="multi-bit buses"></a>multi-bit buses</h3><p>一系列bit的合集称为bus，在hdl中用<code>[]</code>的形式表示buses，和其他语言里的数组一样。获得buses的一部分可以用<code>a[1..2]</code>这种形式，包括<code>a[1]</code> , <code>a[2]</code>. </p>
<h4 id="bus的数组表示"><a href="#bus的数组表示" class="headerlink" title="bus的数组表示"></a>bus的数组表示</h4><p>可以利用index来访问具体的biti.<br>从右向左， a[16]  a[0] 是最右边的bit, the least significant bit LSB, a[15] 是最左边的bit, the most significant bit 也叫MSB</p>
<blockquote>
<p>项目心得<br>注意hdl里数组和常规的访问顺序是倒着的。另外打开模拟软件的时候发现command not found 的时候，注意文件权限<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x xxx.sh</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>computer organization</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
      </tags>
  </entry>
  <entry>
    <title>redux基础</title>
    <url>/2019/06/08/redux-fundamental/</url>
    <content><![CDATA[<h2 id="对象数组操作"><a href="#对象数组操作" class="headerlink" title="对象数组操作"></a>对象数组操作</h2><p>这部分是redux的先知知识</p>
<h3 id="如何保持对象类型数据不可变"><a href="#如何保持对象类型数据不可变" class="headerlink" title="如何保持对象类型数据不可变"></a>如何保持对象类型数据不可变</h3><p>redux里用了很多纯函数的概念，纯函数是没有副作用的函数，没有副作用的函数，无论执行多少次返回都是一样。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="数组添加元素"><a href="#数组添加元素" class="headerlink" title="数组添加元素"></a>数组添加元素</h5><p><code>push()</code>会更改原数组，采用<code>concat</code>或<code>spread</code>操作符<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addCounter = <span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// return list.concat([0]); // old way</span></span><br><span class="line">  <span class="keyword">return</span> [...list, <span class="number">0</span>]; <span class="comment">// ES6 way</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testAddCounter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> listBefore = [];</span><br><span class="line">  <span class="keyword">const</span> listAfter = [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  deepFreeze(listBefore);</span><br><span class="line"></span><br><span class="line">  expect(</span><br><span class="line">    addCounter(listBefore)</span><br><span class="line">  ).toEqual(listAfter);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testAddCounter();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'All tests passed'</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://egghead.io/lessons/javascript-redux-avoiding-array-mutations-with-concat-slice-and-spread" target="_blank" rel="noopener">Dan</a>视频里采用了<a href="https://github.com/mjackson/expect" target="_blank" rel="noopener">expect</a>和<a href="https://github.com/substack/deep-freeze" target="_blank" rel="noopener">deepfreeze</a>库，前者是断言用，deepfreeze用来对对象进行递归<code>freeze</code>.<br><a id="more"></a></p>
<h5 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h5><p><code>splice</code>会更改原数组，<code>slice</code>不会<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> removeCounter = <span class="function">(<span class="params">list, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Old way:</span></span><br><span class="line">  <span class="comment">//return list</span></span><br><span class="line">  <span class="comment">//  .slice(0, index)</span></span><br><span class="line">  <span class="comment">//  .concat(list.slice(index + 1));</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ES6 way:</span></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    ...list.slice(<span class="number">0</span>, index),</span><br><span class="line">    ...list.slice(index + <span class="number">1</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="更改数组元素值"><a href="#更改数组元素值" class="headerlink" title="更改数组元素值"></a>更改数组元素值</h5><p>不能直接采用<code>arr[index]++</code>这种形式，其会更改原有数组，可以采用拼接<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> incrementCounter = <span class="function">(<span class="params">list, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Old way:</span></span><br><span class="line">  <span class="comment">// return list</span></span><br><span class="line">  <span class="comment">//  .slice(0, index)</span></span><br><span class="line">  <span class="comment">//  .concat([list[index] + 1])</span></span><br><span class="line">  <span class="comment">//  .concat(list.slice(index + 1));</span></span><br><span class="line">  <span class="comment">// ES6 way:</span></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    ...list.slice(<span class="number">0</span>, index),</span><br><span class="line">    list[index] + <span class="number">1</span>,</span><br><span class="line">    ...list.slice(index + <span class="number">1</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>当然可以采用将每个值进行循环copy，不过更简单的是采用es6的<code>Object.assign</code>，注意<code>Object.assign</code>的第一个参数是我们要赋值的对象，为了更改原有对象，所以通常采用空对象在这里。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// es6</span></span><br><span class="line">  <span class="comment">// return Object.assign(&#123;&#125;, todo, &#123;</span></span><br><span class="line">  <span class="comment">//   completed: !todo.completed</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="comment">// es7</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...todo,</span><br><span class="line">      completed: !todo.completed</span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="redux-三个原则"><a href="#redux-三个原则" class="headerlink" title="redux 三个原则"></a>redux 三个原则</h2><ol>
<li>single state tree<br>无论应用大小，都只有一个状态树负责这个应用，一个对象管理变化复杂度较低。</li>
<li>state tree is read only<br>state无法直接更改需要通过action告知它如何更改。action也是一个对象，但是必须包含一个<code>type</code>的key.</li>
<li>reducer pure function<br><code>reducer</code>需要是纯函数。所谓的纯函数就是无论函数执行多少次结果都一样，且没有副作用（网络请求，更改dom). 在react中，函数组件由于需要被执行很多次渲染，推荐的做法就是纯函数。<code>reducer</code>中也引入了这个概念，纯函数产生的状态也是最容易跟踪和测试。</li>
</ol>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = Redux.createStore(counter);  <span class="comment">// counter 就是reducer</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h4><p>store上调用<code>dispatch</code>后reducer会进行计算继而更新store<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="string">'INCREMENT'</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="actionCreator"><a href="#actionCreator" class="headerlink" title="actionCreator"></a>actionCreator</h5><p>返回一个action，即dispatch的参数，集中在一个地方可以方便知道这个应用有哪些改变store的行为。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'TOGGLE_TODO'</span>,</span><br><span class="line">    id</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h4><p>相当于一个钩子，每次更新store之后触发订阅的函数</p>
<h4 id="getState"><a href="#getState" class="headerlink" title="getState"></a><code>getState</code></h4><p>获取state tree内的state</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>个人实现，帮助理解，以后参考下源码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function"><span class="params">reducer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">""</span>,</span><br><span class="line">    callbacks = [];</span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    dispatch: <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      state = reducer(state,action);</span><br><span class="line">      callbacks.map(<span class="function"><span class="params">callback</span> =&gt;</span> callback());</span><br><span class="line">    &#125;,</span><br><span class="line">    getState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;,</span><br><span class="line">    subscribe: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      callbacks.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  store.dispatch(&#123;&#125;)</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p><code>reducer</code>接受现在的state tree以及传如的action得出更改后的state tree. 和数组的<code>reduce</code>方法的第一个参数函数很像，接受一个原始值和一个操作返回新的值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上是一个reducer，需要注意的点：</p>
<ol>
<li>要考虑到action未知的情况或者没有传递action的时候返回原始state，利用default</li>
<li>reducer初始的时候就会被调用，初始的state也在这里被声明，利用es6的函数默认值，和上面得到store的个人实现结合起来参考看看是什么时候传入空值的。</li>
<li><code>createStore()</code>的第二个参数可以用来设置初始值，用来覆盖reducer的默认值。比如可以利用localStorage保存状态，下次在进行读取。利用store.subscribe(), 每次store变化时存储state, 避免太频繁调用可以引入throttle, 另外localStorage注意try catch 因为用户可能会禁止。<br><a href="https://redux.js.org/api/createstore#arguments" target="_blank" rel="noopener">arguments</a></li>
</ol>
<h3 id="reducer-composing-with-arrays"><a href="#reducer-composing-with-arrays" class="headerlink" title="reducer composing with arrays"></a>reducer composing with arrays</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          id: action.id,</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo.id !== action.id) &#123;</span><br><span class="line">          <span class="keyword">return</span> todo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...todo,</span><br><span class="line">          completed: !todo.completed</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改过后<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todo = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">      <span class="keyword">if</span> (state.id !== action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        completed: !state.completed</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        todo(<span class="literal">undefined</span>, action)</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">t</span> =&gt;</span> todo(t, action));</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>相应讨论可以见<a href="https://egghead.io/lessons/react-redux-reducer-composition-with-arrays" target="_blank" rel="noopener">评论区</a><br>Dan的做法是将数组处理和单项处理进行了分离，他提到了如果不分离的话增加新的action比如编辑某一个todo事项就会导致重复了更新数组中某一项的逻辑。这处我是理解不了，因为他也重复了switch声明呢，不过Dan也提到了这个项目过小，不能够很有说服力。</p>
<h3 id="reducer-composing-with-object"><a href="#reducer-composing-with-object" class="headerlink" title="reducer composing with object"></a>reducer composing with object</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> visibilityFilter = (</span><br><span class="line">    state = <span class="string">'SHOW_ALL'</span>,</span><br><span class="line">    action</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'SET_VISIBILITY_FILTER'</span>:</span><br><span class="line">        <span class="keyword">return</span> action.filter;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> todoApp = <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="comment">// Call the `todos()` reducer from last section</span></span><br><span class="line">     todos: todos(</span><br><span class="line">      state.todos,</span><br><span class="line">      action</span><br><span class="line">    ),</span><br><span class="line">    visibilityFilter: visibilityFilter(</span><br><span class="line">      state.visibilityFilter,</span><br><span class="line">      action</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有的state都是在一个state对象上管理。不同的key负责不同部分的状态。每次执行了reducer都是返回了一个全新的对象。初始的时候state是空对象，那么空对象的key也是undefined。正好每个小的reducer里也是定义了undefined的时候处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; combineReducers &#125; = Redux; <span class="comment">// CDN Redux import</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">  todos: todos,</span><br><span class="line">  visibilityFilter: visibilityFilter</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>combineReducers是redux提供的合成reducer方法的helper函数，返回的是个reducer方法，不仅仅可以用在根reducer上。<br><a href="https://github.com/reduxjs/redux/blob/master/src/combineReducers.js" target="_blank" rel="noopener">source</a></p>
<h2 id="接入react"><a href="#接入react" class="headerlink" title="接入react"></a>接入react</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function">(<span class="params">props</span>)=&gt;</span>(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;props.value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.onIncrement&#125;&gt;INCREMENT&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">const counter = (state = 1, action)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">  switch(action.type)&#123;</span></span><br><span class="line"><span class="regexp">    case 'INCREMENT':</span></span><br><span class="line"><span class="regexp">      return state +1;</span></span><br><span class="line"><span class="regexp">    default:</span></span><br><span class="line"><span class="regexp">      return state</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const store = createStore(counter);</span></span><br><span class="line"><span class="regexp">const render = ()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">  reactDom.render(&lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;()=&gt;store.dispatch(&#123;type:'INCREMENT'&#125;)&#125;&gt;&lt;/</span>Counter&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(render)</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>
<p>这里是比较简单的实现，store更新的时候绑定了一个回调函数，在这个回调里调用了<code>ReactDom.render</code>的方法进行渲染。每当store更新的时候整个app都进行了重新渲染。可以在组件内订阅store, 每当store更新的时候更新组件，利用forceUpdate()的方法更新当前组件。通常采用一个container组件和redux进行连接，将数据传递给presentational组件。每个组件mount的时候进行订阅，unmount的时候进行取消订阅。<br><a href="https://github.com/tayiorbeii/egghead.io_redux_course_notes/blob/master/17-Extracting_Container_Components_FilterLink.md" target="_blank" rel="noopener">Extracting_Container_Components</a>。</p>
<p>每个组件内的store的来源可以是通过props传递，这样比较明确，但是会导致层层传递props的问题。不过我目前觉得就好像全局变量在模块化的时代可以通过import进来，每个组件内的store可以通过import进来store的实例就可以。就算文中提到的mock store的测试问题，我只在一个地方更改我的store实例不久可以了嘛，暂时留个疑问在这o(╯□╰)o。<a href="https://github.com/tayiorbeii/egghead.io_redux_course_notes/blob/master/19-Passing_the_Store_Down_Explicitly_via_Props.md" target="_blank" rel="noopener">Passing the Store Down Explicitly via Props</a><br>还有一种进行不明确传递store的方法就是利用<code>context</code>. <code>react-redux</code>证实正是用了<code>context</code>.可以在每个组件内访问store. </p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>利用<code>react-redux</code>的connect方法，将 <code>mapStateToProps</code>,<code>mapDispatchToProps</code><br><code>mapStateToProps</code>将store.state里的属性传递给container组件的props, <code>mapDispatchToProps</code>将store.dispatch方法映射到container组件的props. <code>connect</code>方法接受这两个参数并且返回一个高阶组件。最后返回的组件里会将map里定义的props和ComponentA的props进行合并。可以利用<code>ownProps</code>进行ComponentA的props访问. mapStateToProps为空的话将不会在store上订阅当前组件的更新，因为不需要接受state的值。如果<a href="https://react-redux.js.org/using-react-redux/connect-mapdispatch" target="_blank" rel="noopener">mapDispatchToProps</a>是null或者其他falsy value,会默认将dispatch方法作为参数传递。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connect(mapStateToProps,mapDispatchToProps)(ComponentA)</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/tayiorbeii/egghead.io_redux_course_notes" target="_blank" rel="noopener">redux-notes</a></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4插件及工作流程</title>
    <url>/2019/05/06/how-does-webpack4-work/</url>
    <content><![CDATA[<blockquote>
<p>webpack作者是c#出身，很多代码是OOP模式，可以借鉴下</p>
</blockquote>
<h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><p>webpack4重写了<a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">Tapable</a>, 是webpack的插件组织的核心。它提供给各个插件钩子，在事件触发时执行这些挂载的方法。webapck的插件里必须有<code>apply()</code>方法，当其被调用的时候webpack将钩子上的方法挂载到各个事件下面有点像<code>nodejs</code>里<code>EventEmitter</code>的<code>$on</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>() &#123;</span><br><span class="line">		<span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">			accelerate: <span class="keyword">new</span> SyncHook([<span class="string">"newSpeed"</span>]),</span><br><span class="line">			brake: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">			calculateRoutes: <span class="keyword">new</span> AsyncParallelHook([<span class="string">"source"</span>, <span class="string">"target"</span>, <span class="string">"routesList"</span>])</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">    setSpeed(newSpeed) &#123;</span><br><span class="line">		<span class="keyword">this</span>.hooks.accelerate.call(newSpeed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>如上代码所示先是在实例化的过程中注册了三个钩子函数，在实例上调用方法时触发钩子函数。<br>下面介绍webpack里主要的6个<code>Tapable</code>的实例, 它们都继承了<code>Tapable</code>，定义了一些自己的hook</p>
<h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>最高层的实例，初始化配置，提供全局性的钩子比如<code>done</code>, <code>compilation</code>。其他的<code>Tapable</code>实例需要通过其访问，如<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.hooks.compilation.tap(</span><br><span class="line">  <span class="string">"myFirstWebpackPlugin"</span>,</span><br><span class="line">  (compilation, params) =&gt; &#123;</span><br><span class="line">    compilation.hooks.seal.tap()</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h2><p>由<code>Compiler</code>创建，整个构建就在这里完成，进行依赖图构建，优化资源，渲染出runtime时的代码等。下面的4个实例都是发生在这个阶段。</p>
<h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p>当你请求一个模块的时候，你将模块名或者相对地址发给模块解析器，它会去解析出绝对地址去寻找那个模块，看是否存在，如果存在则返回相应的模块信息，包括上下文等。这里的请求可以类似网络请求一样携带上查询参数之类的，<code>Resolver</code>将会返回额外信息。webpack4里将<code>Resolver</code>这个实例抽出来单独发了一个包<code>enhanced-resolve</code>, 抽象出来可以便于用户实现自己的<code>Resolver</code></p>
<h2 id="ModuleFactory"><a href="#ModuleFactory" class="headerlink" title="ModuleFactory"></a>ModuleFactory</h2><p>模块工厂就是负责构造模块的实例，介绍两种<code>NormalModuleFactory</code>和<code>ContextModuleFactory</code>。两者不同的地方在于后者用于解析动态<code>import()</code>. 模块工厂主要是用于将<code>Resolver</code>解析成功的请求里的源码从文件中拿出，在内存中创建一个模块对象（NormalModule）</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p><code>Parser</code>主要用于将代码解析成AST抽象语法🌲.可以在<a href="https://astexplorer.net/" target="_blank" rel="noopener">ast</a>查看代码转换成AST后的样子。webpack默认采用<code>acorn</code>解析器，babel是<code>babylon</code>。<code>Parser</code>将<code>ModuleFactory</code>返回的对象里的代码字符串转换成AST后进行解析，发现<code>import</code>或者<code>require</code>或者<code>define</code>类似模块引用时会将这些引用信息也就是依赖添加到当前模块的对象里，这样每个模块对象里不但有自己模块的信息还包含它的依赖信息。webpack会在不仅仅会在模块声明处触发事件，它甚至会在解析到变量时也触发事件。如下在<code>webpack/lib/Parser.js</code>里可以看到如下三个钩子函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">varDeclaration: <span class="keyword">new</span> HookMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> SyncBailHook([<span class="string">"declaration"</span>])),</span><br><span class="line">varDeclarationLet: <span class="keyword">new</span> HookMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> SyncBailHook([<span class="string">"declaration"</span>])),</span><br><span class="line">varDeclarationConst: <span class="keyword">new</span> HookMap(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> SyncBailHook([<span class="string">"declaration"</span>])),</span><br></pre></td></tr></table></figure></p>
<h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>负责生成运行时的代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line">    <span class="keyword">var</span> multiply  = <span class="built_in">require</span>(<span class="string">'./multiply'</span>)</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">module</span>.exports = sum;</span><br><span class="line"><span class="comment">// multiply.js</span></span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a*b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的runtime</span></span><br><span class="line">[</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> multiply  = __webpack_require__(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">module</span>.exports = sum;</span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a*b</span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如上面代码所示，里面包含三个模板，分别负责chunk, module, dependency. chunk是包含多个模块的数组，就是外面数组的形式；module就是里面用立即执行函数包围的部分;dependency就是将原先<code>import</code>, <code>require</code>等引用模块部分转换成 <code>__webpack_require__</code>.</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><blockquote>
<p>目前只看到模块构建那部分，后续再补充╮(╯_╰)╭。。。心得就是利用好vscode的调试工具多打断点~~</p>
</blockquote>
<p>介绍完了这六个实例，下面大致讲下webpack的工作流程，webpack做的工作非常多，这里只挑主要的讲下。括号里的是源码所在的文件位置，上下文是<code>node_modules/webpack</code>. 本流程基于webpack4.30.0版本。</p>
<ol>
<li>首先是将配置文件读入，webpack4有默认配置<code>options = new WebpackOptionsDefaulter().process(options);</code>会以用户的配置为先。Compiler进行创建<code>compiler = new Compiler(options.context);</code>将配置里的plugin部分进行绑定调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">"function"</span>) &#123;</span><br><span class="line">        plugin.call(compiler, compiler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        plugin.apply(compiler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>进行其他配置设置<code>compiler.options = new WebpackOptionsApply().process(options, compiler);</code><br> (lib/webpack.js)</p>
<ol start="2">
<li>接着根据打包的目标（web, node, electron等）生成不同的打包模板<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (options.target) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"web"</span>:</span><br><span class="line">        JsonpTemplatePlugin = <span class="built_in">require</span>(<span class="string">"./web/JsonpTemplatePlugin"</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"webworker"</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为浏览器端请求异步加载的模块会类似jsonp插入dom中<code>&lt;script&gt;</code>标签，而比如node端是没有dom结构的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> EntryOptionPlugin().apply(compiler);</span><br><span class="line">compiler.hooks.entryOption.call(options.context, options.entry);</span><br></pre></td></tr></table></figure></p>
<p>这部分是将入口处配置添加调用<code>entryOption</code>钩子。<br>(lib/WebpackOptionsApply.js)</p>
<ol start="3">
<li>根据不同接口类型调用不同的类，webpack里到处都是类<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/EntryOptionPlugin.js</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> entry === <span class="string">"string"</span> || <span class="built_in">Array</span>.isArray(entry)) &#123;</span><br><span class="line">        itemToPlugin(context, entry, <span class="string">"main"</span>).apply(compiler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> entry === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">Object</span>.keys(entry)) &#123;</span><br><span class="line">            itemToPlugin(context, entry[name], name).apply(compiler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> entry === <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> DynamicEntryPlugin(context, entry).apply(compiler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里举例是单文件入口, 在compilation钩子上绑定（即<code>Compiler</code>创建<code>compilation</code>后调用）回调，指定当前依赖的模块生成方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.hooks.compilation.tap(</span><br><span class="line">    <span class="string">"SingleEntryPlugin"</span>,</span><br><span class="line">    (compilation, &#123; normalModuleFactory &#125;) =&gt; &#123;</span><br><span class="line">        compilation.dependencyFactories.set(</span><br><span class="line">            SingleEntryDependency,</span><br><span class="line">            normalModuleFactory</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>(lib/SingleEntryPlugin.js)</p>
<ol start="4">
<li>创建<code>compilation</code> (lib/Compiler.js). <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compilation = <span class="keyword">this</span>.createCompilation();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/SingleEntryPlugin.js</span></span><br><span class="line">    compiler.hooks.make.tapAsync(</span><br><span class="line">        <span class="string">"SingleEntryPlugin"</span>,</span><br><span class="line">        (compilation, callback) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; entry, name, context &#125; = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">const</span> dep = SingleEntryPlugin.createDependency(entry, name);</span><br><span class="line">            compilation.addEntry(context, dep, name, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>上面这段是之前注册的，但是会在<code>compilation</code>创建完成前调用，是个异步钩子。<code>compilation</code>创建好后传入，它会将入口创建一个依赖。</p>
<ol start="5">
<li>开始执行<code>addEntry()</code>方法，在<code>addEntry</code>方法里调用<code>_addModuleChain</code>，将当前入口文件创建模块<code>moduleFactory.create</code>，模块创建好后处理当前模块的依赖项<code>this.processModuleDependencies</code>. 将依赖创建模块后再依次解析模块的依赖。（lib/Compilation.js）</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要还是Sean的课程 <a href="https://frontendmasters.com/courses/webpack-plugins/" target="_blank" rel="noopener">webpack-plugins</a></p>
<p><a href="https://medium.com/webpack/the-contributors-guide-to-webpack-part-2-9fd5e658e08c" target="_blank" rel="noopener">contribute-to-webpack</a></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>bundler</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解es module</title>
    <url>/2019/05/01/es-module/</url>
    <content><![CDATA[<h2 id="模块系统的作用"><a href="#模块系统的作用" class="headerlink" title="模块系统的作用"></a>模块系统的作用</h2><p>传统script标签的代码加载容易导致全局作用域污染，而且要维系一系列script的书写顺序，项目一大，维护起来越来越困难。模块系统通过声明式的暴露和引用模块使得各个模块之间的依赖变得明显。</p>
<h2 id="es-module的写法"><a href="#es-module的写法" class="headerlink" title="es module的写法"></a>es module的写法</h2><h3 id="named-export"><a href="#named-export" class="headerlink" title="named export"></a>named export</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;A,B&#125; <span class="keyword">from</span> <span class="string">"a.js"</span></span><br><span class="line"><span class="comment">// 这里用到了解构 destructuring</span></span><br></pre></td></tr></table></figure>
<h3 id="default-export"><a href="#default-export" class="headerlink" title="default export"></a>default export</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="comment">// 这里随便取什么名字</span></span><br></pre></td></tr></table></figure>
<h2 id="es-module如何工作的"><a href="#es-module如何工作的" class="headerlink" title="es module如何工作的"></a>es module如何工作的</h2><p>这部分推荐去看<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener">es-modules-a-cartoon-deep-dive</a>，原文里有图，以下的内容是个人理解整理。</p>
<p><strong>分三步：</strong></p>
<ol>
<li>构造，寻找并且下载所有的文件并且解析成模块记录（Module Records）（包含当前模块代码的抽象语法树，当前模块的依赖模块的信息）。</li>
<li>实例化，将模块记录实例化将各个模块之间的import，export部分对应的都在内存中指向到一起（linking）</li>
<li>执行，将import, export内存里指向的地址填上实际的值。</li>
</ol>
<a id="more"></a>
<h3 id="构造阶段（Construction）"><a href="#构造阶段（Construction）" class="headerlink" title="构造阶段（Construction）"></a>构造阶段（Construction）</h3><p>构造阶段要做三件事情：</p>
<h4 id="解释（interpret）import后的模块指示符（module-specifier）成实际url或者文件地址"><a href="#解释（interpret）import后的模块指示符（module-specifier）成实际url或者文件地址" class="headerlink" title="解释（interpret）import后的模块指示符（module specifier）成实际url或者文件地址"></a>解释（interpret）import后的模块指示符（module specifier）成实际url或者文件地址</h4><p>不同平台根据自己平台的模块解析算法（Module Resolution Algorithm）解释模块指示符，浏览器端目前只接受url做为指示符。不过浏览器将来会同样支持内置模块比如<a href="https://alligator.io/js/kv-storage/" target="_blank" rel="noopener">kv-storage</a>。</p>
<h5 id="模块指示符里的变量"><a href="#模块指示符里的变量" class="headerlink" title="模块指示符里的变量"></a>模块指示符里的变量</h5><p>模块指示符里不能有变量但是node中commonJS是可以有的，因为在commonJS的模块代码里，<code>require</code>声明前的代码是会先执行的，es module是最后一步再去执行，这一步才知道各个变量的具体值是多少。所以可以在node中有如下写法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;path&#125;</span>/sum.js`</span>);</span><br></pre></td></tr></table></figure></p>
<p>不过es module里有另一种写法动态引入<code>import()</code>可以支持在代码执行时动态引入模块，可以在指示符里携带变量<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">`<span class="subst">$&#123;path&#125;</span>/sum.js`</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="浏览器根据url下载文件或者node根据文件地址去加载文件"><a href="#浏览器根据url下载文件或者node根据文件地址去加载文件" class="headerlink" title="浏览器根据url下载文件或者node根据文件地址去加载文件"></a>浏览器根据url下载文件或者node根据文件地址去加载文件</h4><h4 id="将文件解析成模块记录"><a href="#将文件解析成模块记录" class="headerlink" title="将文件解析成模块记录"></a>将文件解析成模块记录</h4><p>浏览器解析常规js文件时会解析完后再执行。和模块的解析策略不一样，这里要告诉浏览器解析的是个模块。在html中：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">"./sum.js"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>ps: 在node中因为没有浏览器这种类似打tag的形式，有种方案是模块文件是<code>.mjs</code>后缀结尾的方案，不过目前尚未敲定。</p>
<p>解析模块文件为模块记录，找到依赖的模块再去下载模块然后解析成模块记录，直到所有的模块都解析成模块记录为止。模块记录会存在当前全局的一个模块映射里（Module Map）,可以理解成一个缓存，下次再有相同url的模块请求就直接从模块映射里拿出模块记录即可。</p>
<h3 id="实例化阶段"><a href="#实例化阶段" class="headerlink" title="实例化阶段"></a>实例化阶段</h3><p>将上面得到的模块记录类实例化。<br>首先在内存中指定位置给各个模块的<code>export</code>导出的变量或者函数，接着将模块中对应的<code>import</code>部分同样指向对应的<code>export</code>的内存地址。<br>举个🌰<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;obj&#125; <span class="keyword">from</span> <span class="string">"./obj.js"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.js</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;obj&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>obj.js</code>文件里导出的<code>obj</code>和<code>main.js</code>文件里引用的<code>obj</code>是指向同一个内存地址的，这种方法就是动态绑定（live binding）。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'module'</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123;obj&#125; <span class="keyword">from</span> <span class="string">"./obj.js"</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(obj);  <span class="comment">//&#123;a: 123&#125;</span></span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(obj)  <span class="comment">//&#123;b: 233&#125;</span></span></span><br><span class="line"><span class="undefined">  &#125;, 2000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    obj = &#123; <span class="attr">b</span>: <span class="number">233</span> &#125;;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">export</span> &#123; obj &#125;;</span><br></pre></td></tr></table></figure>
<p>下面我们看下node中同样的代码的效果。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test1.js</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">require</span>(<span class="string">"./test2.js"</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(obj); <span class="comment">// &#123;a: 123&#125;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.dir(obj); <span class="comment">// &#123;a: 123&#125;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// test2.js</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">123</span> &#125;;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    obj = &#123; <span class="attr">b</span>: <span class="number">233</span> &#125;;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">module</span>.exports = obj;</span><br></pre></td></tr></table></figure></p>
<p>在commonJS中<code>require</code>一个对象是在内存中复制一份导出模块的对象。动态绑定主要解决的问题就是循环引用的问题，循环引用在下面的执行阶段进行解释。<br><em>注意：</em><br>es module中可以在模块导出的部分更改导出值如上面代码所示，但是不能在引入部分更改。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;obj&#125; <span class="keyword">from</span> <span class="string">"./sum.js"</span></span><br><span class="line">obj = <span class="string">'233'</span>  <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></p>
<p>如上报错会提示不能给常量赋值，不过如果是对象的话可以更改内部的key，由于动态绑定的原因，导出部分也会发生改变<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">    <span class="keyword">import</span> &#123;obj&#125; <span class="keyword">from</span> <span class="string">"./obj.js"</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        obj.a = <span class="string">'嘻嘻'</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// obj.js</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 123&#125;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: "嘻嘻"&#125;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">export</span> &#123; obj &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="执行阶段（evaluate）"><a href="#执行阶段（evaluate）" class="headerlink" title="执行阶段（evaluate）"></a>执行阶段（evaluate）</h3><p>原文中是evaluate，我这里理解成了执行，如有不对欢迎指出。引擎开始执行模块了，每个模块只会被执行一次。在上面提到过的module map里的模块记录里会存有当前模块的状态是实例化中还是实例完成还是执行完成等。可以避免同一个模块文件被多次执行。</p>
<h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p>如下在<strong>node</strong>中，两个模块互相引用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test1.js</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"./test2"</span>).b;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="string">"test1: "</span> + b);  <span class="comment">// 'test1: test2' 🥈</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"test1"</span>;</span><br><span class="line">    exports.a = a;</span><br><span class="line"><span class="comment">// test2.js</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./test1"</span>).a;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test2: "</span> + a);  <span class="comment">// test2: undefined 🥇</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"test2"</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"test2: "</span> + a); <span class="comment">// test2: undefined 🥉</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    exports.b = b;</span><br><span class="line"></span><br><span class="line">    node test1.js <span class="comment">// 启动</span></span><br></pre></td></tr></table></figure></p>
<p><em>ps: emoji里表示打印顺序</em><br>node执行某个模块时会将当前模块的代码放入函数中，向这个函数传递<code>module</code>, <code>module.exports</code>, <code>__dirname</code>等参数。初始的<code>module</code>就是一个空对象。<br>test1.js执行遇到<code>require(&#39;./test2)</code>时会进入test2模块开始执行，这个时候又碰到引用test1模块的东西；因为test1模块没有执行完成，它的<code>module.exports</code>还是空对象，所以这个时候test2里的<code>a</code>是<code>undefined</code>。因为commonJS不是动态绑定的，so等到test1模块执行完<code>a</code>变量里还是<code>undefined</code><br><strong>es module</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es1 </span></span><br><span class="line">    <span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">"./es2.js"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"es1: "</span> + b); <span class="comment">// es1: es2 🥈</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"es1"</span>;</span><br><span class="line">    <span class="keyword">export</span> &#123; a &#125;;</span><br><span class="line"><span class="comment">// es2</span></span><br><span class="line">    <span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">"./es1.js"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"es2: "</span> + a); <span class="comment">// es2: undefined 🥇</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"es2"</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"es2: "</span> + a); <span class="comment">// es2: es1 🥉</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">export</span> &#123; b &#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上代码入口是es1文件。根据打印顺序来看先是执行的es2模块，之后es1里的<code>a</code>填充了实际值，由于是动态绑定es2中的<code>a</code>中的值也在之后能取到值了。</p>
<h2 id="es-module的好处"><a href="#es-module的好处" class="headerlink" title="es module的好处"></a>es module的好处</h2><ol>
<li>动态绑定解决了循环调用的问题（见上文）</li>
<li>静态分析（statically analysis）<br>因为在代码未执行阶段就已经知道当前模块导入了什么，导出了什么，所以有些工具就可以进行静态分析。比如vscode中引入模块代码时会提示当前模块里导出的内容。</li>
</ol>
<h2 id="es-module的坏处"><a href="#es-module的坏处" class="headerlink" title="es module的坏处"></a>es module的坏处</h2><ol>
<li>兼容性</li>
<li>尚未有针对node的解决方案</li>
</ol>
<h2 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h2><p>为什么module records是个类，每个模块都有个module records但是它也只是实例化一个实例，那类的作用是什么。这部分需要仔细看下规范~~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener">es-modules-a-cartoon-deep-dive</a></p>
<p><a href="http://2ality.com/2015/07/es6-module-exports.html" target="_blank" rel="noopener">module-exports</a></p>
<p><a href="https://tc39.github.io/ecma262/#sec-abstract-module-records" target="_blank" rel="noopener">ecma262</a></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4 基础🐱</title>
    <url>/2019/05/01/webpack4-fundamental/</url>
    <content><![CDATA[<p>根据Sean在 frontend masters上的课程加上个人的理解<br>Sean 是 webpack 的核心贡献者哦😯<a href="https://github.com/thelarkinn/webpack-workshop-2018" target="_blank" rel="noopener">课程代码</a></p>
<h2 id="为什么要使用webpack"><a href="#为什么要使用webpack" class="headerlink" title="为什么要使用webpack"></a>为什么要使用webpack</h2><h3 id="传统方法在浏览器中执行JS"><a href="#传统方法在浏览器中执行JS" class="headerlink" title="传统方法在浏览器中执行JS"></a>传统方法在浏览器中执行JS</h3><ol>
<li>一个功能加载一个script 标签 e.g. <code>Jquery</code> , <code>Swiper</code></li>
<li>加载一个巨大的JS文件。</li>
</ol>
<h4 id="script标签加载的弊端"><a href="#script标签加载的弊端" class="headerlink" title="script标签加载的弊端"></a>script标签加载的弊端</h4><ol>
<li>扩展性太差，标签很多的情况下维持标签的顺序很痛苦。</li>
<li>全局变量污染</li>
<li>加载过多的JS文件有加载性能问题，因为浏览器的并行连接数有限制。可以参考<a href="https://stackoverflow.com/questions/985431/max-parallel-http-connections-in-a-browser" target="_blank" rel="noopener">html - Max parallel http connections in a browser? - Stack Overflow</a><a id="more"></a>
</li>
</ol>
<h4 id="单独一个JS文件的弊端"><a href="#单独一个JS文件的弊端" class="headerlink" title="单独一个JS文件的弊端"></a>单独一个JS文件的弊端</h4><p>这里应该是说所有代码写在一起，不是按照模块组织最后打包出一个文件来的。</p>
<ol>
<li>不同功能的作用域问题</li>
<li>用户需要加载的文件过大。</li>
<li>维护性和可读性很差。</li>
</ol>
<h3 id="立即执行函数IIFEs"><a href="#立即执行函数IIFEs" class="headerlink" title="立即执行函数IIFEs"></a>立即执行函数IIFEs</h3><p>Immediately invoked function expressions<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outerScope = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> whatever = (<span class="function"><span class="keyword">function</span>(<span class="params">dataNowUsedInside</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> outerScope = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    someAttribute: <span class="string">"you want"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(outerScope);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>立即执行函数可以解决作用域冲突的问题，如上因为函数作用域的存在不会污染外部作用域。<br>PS: 另外上面的这个暴露出一个模块的模式叫<em>Revealing Module pattern</em> 可以参考 <a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript" target="_blank" rel="noopener">Learning JavaScript Design Patterns</a></p>
<p><code>Make</code>, <code>Gulp</code>, <code>Grunt</code>, <code>Broccoli</code> ,  <code>Brunch</code> 这些工具通过一个文件当做一个立即执行函数，将这些立即执行函数连接起来打包成一个文件。</p>
<p>这些工具的弊端：</p>
<ol>
<li>每次更改一个文件都要重新构建所有文件</li>
<li>无法剔除没有使用过的代码，比如引入<code>Lodash</code>, 就用了几个函数，结果500Kb的文件都被引入了。</li>
<li>立即执行函数过多的话可能会造成性能问题。 参考这篇文章<a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/" target="_blank" rel="noopener">The cost of small modules | Read the Tea Leaves</a>。文章里提到一个是函数内嵌套函数，还有在关联数组中查看模块在模块越来越多的情况下会暴露出意外的性能问题。另外立即执行函数会导致引擎立刻解析函数 (eager parse)，大量的立即执行函数也会导致应用解析变慢。</li>
<li>没法做懒加载。</li>
</ol>
<h3 id="Javascript模块优缺点"><a href="#Javascript模块优缺点" class="headerlink" title="Javascript模块优缺点"></a>Javascript模块优缺点</h3><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p><code>node</code>里没有<code>&lt;script&gt;</code>标签，怎么加载JS代码呢，于是出来了CommonJS. </p>
<ol>
<li>但是 CommonJS 不支持浏览器</li>
<li>没有动态绑定，什么是动态绑定可以参考 <a href="/2019/05/01/es-module/" title="深入理解es module">深入理解es module</a></li>
<li>CommonJS解析算法慢，因为它是同步的</li>
<li>没有静态分析，没法剔除无用代码</li>
</ol>
<h4 id="打包器"><a href="#打包器" class="headerlink" title="打包器"></a>打包器</h4><p>开发者不愿意从某个库的网上下载JS文件然后放到项目中来，他们想通过NPM分享模块代码。但是NPM上的是CommonJs模块的，所以就出现了<code>Browserify</code> 之类的工具把CommonJS风格的代码解析<code>require</code>声明，按照你引用的顺序打包成浏览器可以执行的代码。</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>除了CommonJS还有很多模块加载模式。甚至还有AMD+CommonJS的模块加载模式。</p>
<p>没有真正的模块系统，没有node 浏览器都支持的。直到<code>ESM</code>的出现。</p>
<h4 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h4><p>ES2015和模块是独立的两个部分。模块标准原名是<em>harmony modules specification</em>。你甚至可以用ES3的语法搭配模块使用。<br>ESM的问题：</p>
<ol>
<li>node 中的ESM尚未实现。</li>
<li>兼容问题。</li>
</ol>
<h2 id="webpack-能做什么"><a href="#webpack-能做什么" class="headerlink" title="webpack 能做什么"></a>webpack 能做什么</h2><p>webpack 是一个模块打包器</p>
<ol>
<li>库的作者使用他们喜欢的模块系统，AMD, CommonJS, webpack 可以让你使用任何的模块格式甚至混合，将它们最终打包成浏览器可以执行的代码。</li>
<li>在构建阶段创建动态打包模块（懒加载的模块）</li>
<li>不仅打包JS资源还包括html, css甚至图片</li>
</ol>
<h2 id="调试webpack"><a href="#调试webpack" class="headerlink" title="调试webpack"></a>调试webpack</h2><ol>
<li>按照调试node的方法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node --inspect --inspect-brk ./node_modules/webpack/bin/webpack.js</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>之后在浏览器中打开，可以参考<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" target="_blank" rel="noopener">debugger</a></p>
<ol start="2">
<li>利用vscode<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">        <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">        <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/node_modules/webpack/bin/webpack.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以参考下<a href="https://medium.com/@jsilvax/debugging-webpack-with-vs-code-b14694db4f8e" target="_blank" rel="noopener">debugging-webpack</a></p>
<h2 id="webpack-基础概念"><a href="#webpack-基础概念" class="headerlink" title="webpack 基础概念"></a>webpack 基础概念</h2><h2 id="什么是依赖图（dependency-graph）"><a href="#什么是依赖图（dependency-graph）" class="headerlink" title="什么是依赖图（dependency graph）"></a>什么是依赖图（dependency graph）</h2><p>webpack根据模块之间的依赖关系递归构建而成<br><a href="https://webpack.js.org/concepts/dependency-graph/" target="_blank" rel="noopener">dependency-graph</a></p>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>告诉webpack从那个文件开始构建它的依赖图。webpack4默认配置是<code>src/index.js</code></p>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>告诉webpack打包好的文件的位置名称等。webpack4默认配置会打包到<code>dist/main.js</code></p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack开箱只理解js和json文件。loader可以将其他模块加载进来转换成js 模块，然后加载到依赖图里。webpack默认使用的是<a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener">acorn</a> 解析js文件，acorn默认只会处理stage4的提案。所以比较新的特性webpack是处理不了的，这个时候可以借助<a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a><br>这里举两个loader</p>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>babel-loader8.x需要配合使用的是@babel-core以及@babel/preset-env</em><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></p>
<p><strong>babel-loader:</strong> webpack和babel之间的桥梁<br><strong>@babel/core:</strong> 解析文件并且生成文件<br><strong>@babel/preset-env:</strong> 相应的转换规则</p>
<h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css loader"></a>css loader</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D css-loader style-loader</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    loaders: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loader解析顺序是从右向左可以 可以理解成这样<code>styleLoader(cssLoader())</code> 一个方法的输出是另一个方法的参数。<br><strong>css-loader:</strong> 负责将css文件转换成js<br><strong>style-loader:</strong> 将css内容插入<code>&lt;style&gt;</code>标签中<br><em>ps:我在安装了相关loader之后, 在vscode里去尝试从node_modules目录里找发现怎么也找不到相关loader o(╯□╰)o，最后我直接打开了文件目录找到了。。。</em></p>
<h3 id="如何写一个loader"><a href="#如何写一个loader" class="headerlink" title="如何写一个loader"></a>如何写一个loader</h3><p><a href="https://webpack.js.org/contribute/writing-a-loader/" target="_blank" rel="noopener">write-a-loader</a><br>总结下就是loader是一个函数，在webpack配置里可以配置loader的别名，以及你自己写的loader的解析位置。<br>函数的参数就是上一个loader处理好后的字符串。loader也分同步和异步的，babel-loader就是异步的。</p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>plugin可以在webpack的构建的任意时刻执行一些特定任务，比如打包优化，插入环境变量等。<br>webpack源码有很大部分都是插件写的，具体会再出一篇详细讲下webpack是如何工作的，这里就简单介绍下。</p>
<h3 id="如何写一个插件"><a href="#如何写一个插件" class="headerlink" title="如何写一个插件"></a>如何写一个插件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myFirstWebpackPlugin</span> </span>&#123;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">        compiler.hooks.done.tapAsync(<span class="string">'myFirstWebpackPlugin'</span>,(stats, cb)=&gt;&#123;</span><br><span class="line">            cb();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = myFirstWebpackPlugin</span><br></pre></td></tr></table></figure>
<p>以上代码是基于webpack4的，3.x的版本是如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myFirstWebpackPlugin</span> </span>&#123;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">        compiler.plugin(<span class="string">"done"</span>,(stats)=&gt;&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = myFirstWebpackPlugin</span><br></pre></td></tr></table></figure></p>
<p>3.x版本的hook是字符串形式，需要人为去记忆，在webpack4中将其作为变量的属性，文档化后在编辑器中输入会有提示，目前尚未文档化完成。4.x版本的hook提供一个可选参数告诉当前挂载进去的方法名，可以用于调试。</p>
<p>插件可以在webpack构建的任意时刻执行，和钩子函数一样，提前在这些时间点注册回调函数，插件的钩子同样可以是同步或者异步的。上面的实例是在构建完成后执行，回调函数的参数里包括一系列统计数据，构建开始时间结束时间等。</p>
<h2 id="webpack代码拆分（code-splitting）"><a href="#webpack代码拆分（code-splitting）" class="headerlink" title="webpack代码拆分（code splitting）"></a>webpack代码拆分（code splitting）</h2><p>代码拆分的用途：</p>
<ol>
<li>不需要在首屏加载的比较大的第三方库比如three.js</li>
<li>模态框提示框等用户可能不会去点击的</li>
<li>路由组件</li>
</ol>
<p>代码拆分的好处：</p>
<ol>
<li>提升首屏加载速度，提升用户体验特别是移动端</li>
<li>有助于提升SEO，google会降低加载慢的网站的权重</li>
</ol>
<p>webpack会将<code>import()</code>引用的模块打包到单独打包到输出目录下，webpack内置的<code>acorn</code>解析器默认是只解析stage4的，<code>import()</code>仍然在stage3，<a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">proposals</a>。这是因为webpack引用了<code>acorn-dynamic-import</code>可以支持在不使用babel的情况下解析<code>import()</code>语法。如果项目中使用了<code>babel-loader</code>需要再配置<code>@babel/plugin-syntax-dynamic-import</code>，否则babel会报错，因为babel也是需要将代码解析转换成抽象语法树的。<br>webpack代码拆分分为静态和动态代码拆分，但是无论哪种，都是将异步请求的模块提前打包到输出目录中。</p>
<p><em>ps:chrome中可以查看code coverage查看当前页面的代码使用率</em></p>
<h3 id="静态代码拆分（static-code-splitting）"><a href="#静态代码拆分（static-code-splitting）" class="headerlink" title="静态代码拆分（static code splitting）"></a>静态代码拆分（static code splitting）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">    <span class="keyword">const</span> getFooter = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./footer'</span>);</span><br><span class="line">    button.addEventListener(<span class="string">'click'</span>,e=&gt;&#123;</span><br><span class="line">        getFooter().then(<span class="function"><span class="params">m</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(m.footer)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// footer.js</span></span><br><span class="line"><span class="keyword">const</span> footer = <span class="built_in">document</span>.createElement(<span class="string">"footer"</span>);</span><br><span class="line"><span class="keyword">export</span> &#123; footer &#125;;</span><br></pre></td></tr></table></figure>
<p><code>import()</code>返回的是一个<code>promise</code></p>
<h3 id="动态代码拆分（dynamic-code-splitting）"><a href="#动态代码拆分（dynamic-code-splitting）" class="headerlink" title="动态代码拆分（dynamic code splitting）"></a>动态代码拆分（dynamic code splitting）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setButtonStyle = <span class="function"><span class="params">color</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">`./button-style/<span class="subst">$&#123;color&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>上面的<code>./button-style</code>是部分地址，webpack会将这个地址下面的所有js模块进行单独打包。这个可以用在当这个目录下有很多文件需要代码拆分的时候。</p>
<h3 id="魔法注释（magic-comment）"><a href="#魔法注释（magic-comment）" class="headerlink" title="魔法注释（magic comment）"></a>魔法注释（magic comment）</h3><p>内联注释控制webpack动态打包行为，为什么要使用它？因为这样不会增加新语法，不和动态import以及<a href="https://github.com/whatwg/loader" target="_blank" rel="noopener">loader</a>规范冲突。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="comment">/* webpackMode: "lazy-once" */</span></span><br><span class="line">    <span class="string">`./button-style/<span class="subst">$&#123;color&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></p>
<p>比如上面这个<code>webpackMode</code>默认是<code>lazy</code>它会将<code>./button-style</code>下的所有模块都单独打包；<code>lazy-once</code>则会将其下面的所有模块打成一个包常用于开发环境减少打包次数。<br>更多注释选项请参考官网<a href="https://webpack.js.org/api/module-methods/#magic-comments" target="_blank" rel="noopener">magic-comments</a></p>
<h3 id="流行库中的代码拆分"><a href="#流行库中的代码拆分" class="headerlink" title="流行库中的代码拆分"></a>流行库中的代码拆分</h3><p><a href="https://medium.com/js-dojo/3-code-splitting-patterns-for-vuejs-and-webpack-b8fff1ea0ba4" target="_blank" rel="noopener">vue-code-splitting-pattern</a><br><a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadable</a></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>bundler</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>懒加载</title>
    <url>/2019/04/30/lazy-load/</url>
    <content><![CDATA[<h3 id="懒加载的好处"><a href="#懒加载的好处" class="headerlink" title="懒加载的好处"></a>懒加载的好处</h3><ol>
<li>减少资源请求，减少用户流量浪费</li>
<li>图片视频下载下来后，浏览器还要调用系统资源进行解码，懒加载后可以减少这部分时间及资源的浪费。</li>
</ol>
<h3 id="懒加载实现"><a href="#懒加载实现" class="headerlink" title="懒加载实现"></a>懒加载实现</h3><h4 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"celebration.jpg"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> <span class="attr">alt</span>=<span class="string">"..."</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过还早的很，说是chrome 75版本支持，我拿76试了下还是不行😶<br>以下的方法主要是判断元素是否在视窗内</p>
<h4 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h4><a id="more"></a>
<img src="/2019/04/30/lazy-load/D035F71E-21AE-4FF1-81F0-8756340D2AE6.png">
<p>兼容性如上图所示，有polyfill版本<a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill" target="_blank" rel="noopener">polyfill IntersectionObserver</a><br>创建一个<code>intersection Observer</code>实例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span>(<span class="params">entries, observer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// entries是个数组</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开始观察某个元素</span></span><br><span class="line">io.observe(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察某个元素</span></span><br><span class="line"><span class="comment">// io.unobserve(element);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的观察都失效</span></span><br><span class="line"><span class="comment">// io.disconnect();</span></span><br></pre></td></tr></table></figure></p>
<p>回调函数的<code>entry.isIntersecting</code>可以判断当前被观察的元素是否和视窗相交也就是是否在视窗内。默认配置是当一个元素只要有一个像素在视窗内<code>entry.isIntersecting</code>就为<code>true</code>。可以配置整个元素所有像素都可见才算数，或者百分之多少才算数。可以在回调里判断进入视窗后调用<code>unobserve(element)</code> 取消监听。</p>
<h5 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h5><p>性能好，不用监听<code>scroll</code>, <code>resize</code>, <code>orientationchange</code> 等事件。<br>劣势就是兼容问题，不过可以利用polyfill.</p>
<h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>获取元素在当前视窗内的大小位置，位置是距离顶部的距离，可以和<code>innerHeight</code>等配合判断是否在页面中。</p>
<h5 id="优势和劣势-1"><a href="#优势和劣势-1" class="headerlink" title="优势和劣势"></a>优势和劣势</h5><p><code>Intersection Observer</code>的优势就是它的劣势，劣势就是它的优势╮(╯_╰)╭</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://css-tricks.com/native-lazy-loading/" target="_blank" rel="noopener">Native Lazy Loading | CSS-Tricks</a><br><a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" target="_blank" rel="noopener">Lazy Loading Images and Video  |  Web Fundamentals       |  Google Developers</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">Intersection Observer API - Web APIs | MDN</a></p>
]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（hash table）基础</title>
    <url>/2019/04/29/hash-table/</url>
    <content><![CDATA[<h2 id="散列表是什么"><a href="#散列表是什么" class="headerlink" title="散列表是什么"></a>散列表是什么</h2><p>散列表基本思想是将key按照一定方法（hash function）映射到数组的index，数组按照index访问是可以实现常数级的复杂度。散列表是经典的时间和空间的tradeoff. 如果空间无限则可以避免下面出现的冲突问题，如果时间无限，每次遍历储存结构即可。在java中有<code>java.util.HashMap</code>, <code>java.util.IdentityHashMap</code>这些数据结构的应用。</p>
<h2 id="为什么要用散列表"><a href="#为什么要用散列表" class="headerlink" title="为什么要用散列表"></a>为什么要用散列表</h2><p>红黑树的查找和插入以及删除项目平均时间复杂度都是对数级的，散列表在某些条件下比红黑树表现更好，可以实现平均常数级的查找和插入：</p>
<ol>
<li>不关心数据是否是按照顺序存储的，红黑树中数据都是按照一定顺序存储的</li>
<li>散列函数不太复杂的情况下<br>不过红黑树能够保证性能，散列表的性能表现是有前提的。</li>
</ol>
<h2 id="散列表需要解决的问题"><a href="#散列表需要解决的问题" class="headerlink" title="散列表需要解决的问题"></a>散列表需要解决的问题</h2><ol>
<li>散列函数（hash function）</li>
<li>解决冲突问题。为什么会有冲突问题：统计学试验表明，如果想要不冲突就需要指数级的存储空间。现实生活中我们的资源都是有限的，so~<a id="more"></a>
<h2 id="散列函数（hash-function）"><a href="#散列函数（hash-function）" class="headerlink" title="散列函数（hash function）"></a>散列函数（hash function）</h2>散列函数要能满足两个条件：</li>
<li>key不要太复杂便于计算hash</li>
<li>散列表的每个index对于任意插入表的key都有同等的可能性。比如有M个key，散列函数要能将这M个值均匀的散布在0~M-1的数组index上。就好像Math.random()它生成的数其实不是真正意义的随机，生成每个数的可能性不尽相同。<br>至于为什么要均匀散布呢？我觉得应该是更高效的利用空间，否则冲突就会更提前发生。</li>
</ol>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hashCode的作用是将数据类型转化为数组，方便进行散列计算。</p>
<h4 id="java的hashCode实现"><a href="#java的hashCode实现" class="headerlink" title="java的hashCode实现"></a>java的hashCode实现</h4><p>java的内置数据类型都继承了一个方法<code>hashCode</code>,它返回一个32-bit<code>ini</code>。比如<code>Integer</code>就直接返回数值本身，<code>Boolean</code>返回两个特定的<code>int</code>。<code>String</code>的实现用到了一个<em>Horner’s method</em>. <code>s[i]</code>这边是代表那个字符的Unicode.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length(); i++)</span><br><span class="line">   hash = s[i] + (<span class="number">31</span> * hash);</span><br><span class="line">   <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自定义类型的hashCode实现"><a href="#自定义类型的hashCode实现" class="headerlink" title="自定义类型的hashCode实现"></a>自定义类型的hashCode实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">    hash = <span class="number">31</span>*hash + who.hashCode();</span><br><span class="line">    hash = <span class="number">31</span>*hash + when.hashCode();</span><br><span class="line">    hash = <span class="number">31</span>*hash + ((Double) amount).hashCode();</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的who, when, amount 是举例用户类型里的各种类型的值，要保证每个值都参与运算。<br>java设计清单：</p>
<ol>
<li>每个关键字段要参与运算可以考虑31x + y这种规则。为什么是31？</li>
<li>如果字段是基本类型，需要用到wrapper再调用<code>hashCode</code></li>
<li>如果字段是null，则返回0</li>
<li>如果是引用类型，则调用<code>hashCode</code></li>
<li>如果字段是个数组，数组每个元素都调用，引用类型就递归调用 <code>Array.deepHashCode()</code></li>
</ol>
<p>另外实现的时候为了性能考虑，在第一次调用的时候将结果缓存在局部变量内，第二次调用直接返回这个局部变量</p>
<h3 id="除留余数法（modular）"><a href="#除留余数法（modular）" class="headerlink" title="除留余数法（modular）"></a>除留余数法（modular）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125;</span><br></pre></td></tr></table></figure>
<p>因为hashCode返回的是<code>int</code>，可能是负数，因为映射的是数组的index，所以上面代码会讲一个32位整数变为一个非负整数；另外M一般会选素数（prime）。因为如果不是素数的比如100，那么212, 612的余数都是12。而如果采用了M为97则分别余数是18和30。素数更能有效利用所有数。</p>
<h3 id="冲突解决方案（collision）"><a href="#冲突解决方案（collision）" class="headerlink" title="冲突解决方案（collision）"></a>冲突解决方案（collision）</h3><p>介绍一个统计学模型</p>
<h4 id="球和球筒模型-Balls-and-Bins-model"><a href="#球和球筒模型-Balls-and-Bins-model" class="headerlink" title="球和球筒模型 (Balls and Bins model)"></a>球和球筒模型 (Balls and Bins model)</h4><p>球对应着即将插入散列表的key, 筒对应着散列表的数组，数组的每个index就是一个筒。<br>将球随机均匀的扔入各个筒中开始试验，最后得出的结论是：</p>
<ol>
<li>要想两个球不同入同一个筒中，你需要很大的指数级的筒。</li>
<li>冲突（不同球投入同一个筒中）是均匀分布的。</li>
</ol>
<h4 id="方案一拉链法（separate-chaining）"><a href="#方案一拉链法（separate-chaining）" class="headerlink" title="方案一拉链法（separate chaining）"></a>方案一拉链法（separate chaining）</h4><p>有N个key，table长度是M。目的是把N个key放入0~M-1中去。拉链法运用了链表，table的每个位置都是放置的一个链表。<br>根据上面的模型来看，平均每个链表的长度都是N/M。<br>插入时：根据key算出hash值（0~M-1）后，放入那个位置链表的最前面。</p>
<p>搜索时：根据key算法hash值（0~M-1）后，遍历那个位置的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">97</span>; <span class="comment">// number of chains 仅仅表示举例</span></span><br><span class="line">    <span class="keyword">private</span> Node[] st = <span class="keyword">new</span> Node[M]; <span class="comment">// array of chains</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object key;</span><br><span class="line">        <span class="keyword">private</span> Object val;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Node x = st[i]; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        <span class="keyword">if</span> (key.equals(x.key)) <span class="keyword">return</span> (Value) x.val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Node x = st[i]; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        <span class="keyword">if</span> (key.equals(x.key)) &#123; x.val = val; <span class="keyword">return</span>; &#125;</span><br><span class="line">        st[i] = <span class="keyword">new</span> Node(key, val, st[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="拉链法分析"><a href="#拉链法分析" class="headerlink" title="拉链法分析"></a>拉链法分析</h5><p>比较次数（比较可以调用<code>equals</code>，如果key相同的情况覆盖）是和N/M成比例的。<br>如果M过大就会导致很多空链，M过小会导致链表过长，典型的选择是大概5倍关系。当然这些前提是在散列方法均匀散列。</p>
<h4 id="方案二线性探测法（linear-probing）"><a href="#方案二线性探测法（linear-probing）" class="headerlink" title="方案二线性探测法（linear probing）"></a>方案二线性探测法（linear probing）</h4><p>线性探测法归属于开放地址法（Open addressing）和上面的方案一样都是早在1953年被发明的。<br>假设有N个key等待插入，数组的长度是M，线性探测法不利用额外空间，只用到一个数组。<br>插入时：hash的位置没有值时直接插入；有值时则往数组的下一个位置探测，没有值则插入，有值则继续探测直到有位置可以插入，到达数组最后一位时从数组index为0的位置再继续。<br>搜索时：hash的位置的键和被查找的键相同；hash的位置为空表示没有这个键存在；hash的位置的键和被查找的不一致则继续查找如果找到一个空位置则代表待搜索的键不存在。</p>
<p>java实现如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">30001</span>;</span><br><span class="line"> <span class="keyword">private</span> Value[] vals = (Value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line"> <span class="keyword">private</span> Key[] keys = (Key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123; <span class="comment">/* as before */</span> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i+<span class="number">1</span>) % M)</span><br><span class="line">    <span class="keyword">if</span> (keys[i].equals(key))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    keys[i] = key;</span><br><span class="line">    vals[i] = val;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i+<span class="number">1</span>) % M)</span><br><span class="line">    <span class="keyword">if</span> (key.equals(keys[i]))</span><br><span class="line">    <span class="keyword">return</span> vals[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用到两个数组一个来存放key，一个用来存放值。上面的代码省略了resize部分，其保证数组不满。</p>
<h5 id="线性探测法的性能"><a href="#线性探测法的性能" class="headerlink" title="线性探测法的性能"></a>线性探测法的性能</h5><p>早期内存开销很重要，研究者们想要充分利用内存他们就去研究纠正什么数组满到什么情况下能保证查找和插入的性能不差。<br>键簇（cluster）：<br>数组有012345个位置，keyA,keyB,keyC都hash到位置0，按照A,B,C顺序插入，则最终A落在了位置0，B落在了位置1，C落在了位置2。<br>012三个位置就组成了一个键簇，因为他们之间是插入不了其他key的新来的不管是hash到0还是1还是2位置都要在这个簇后面插入。。解释的有点生硬可以参考<a href="https://www.coursera.org/learn/algorithms-part1/lecture/He696/linear-probing" target="_blank" rel="noopener">linear-probing</a>的视频。<br>随着插入次数越来越多，cluster越来越长，不同的cluster甚至会融合。想要保证性能平均的cluster就不能过长。<br>根据数学家Knuth的分析有一个公式，公式比较复杂就不列了。假设有N=aM  N个key, 数组长度是M。<br>a越接近于1则探测（prob）次数越多，意味着cluster越大。在a等于1/2时，平均查找需要探测3次，插入需要探测5次。</p>
<h5 id="线性探测法的总结"><a href="#线性探测法的总结" class="headerlink" title="线性探测法的总结"></a>线性探测法的总结</h5><p>在散列方法均匀散列的情况下，保证数组长度是要插入的键的两倍可以得到常数级的时间复杂度。</p>
<h2 id="散列表在实际生活中"><a href="#散列表在实际生活中" class="headerlink" title="散列表在实际生活中"></a>散列表在实际生活中</h2><h3 id="算法复杂度攻击（algorithmic-complexity-attacks）"><a href="#算法复杂度攻击（algorithmic-complexity-attacks）" class="headerlink" title="算法复杂度攻击（algorithmic complexity attacks）"></a>算法复杂度攻击（algorithmic complexity attacks）</h3><p>因为上面提到的常数时间复杂度是有个前提是在散列方法均匀散列的情况下。有些攻击者通过阅读java的String的API，将很多hashCode值一样的字符串塞给你。会导致你的散列表比如上面的探测法里的cluster越来越长。</p>
<h3 id="单向散列（one-way-hash-function）"><a href="#单向散列（one-way-hash-function）" class="headerlink" title="单向散列（one-way hash function）"></a>单向散列（one-way hash function）</h3><p>将一段长度的字符串散列成固定长度的字符串，人们很难去得到原先值。常用语电子指纹，信息摘要，密码存储。<br>常见的有MD4, MD5, SHA-0, SHA-1这些，不过它们也不是绝对安全的。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>初涉grid布局🐱（二）</title>
    <url>/2019/04/25/understanding-grid-2/</url>
    <content><![CDATA[<p>上一篇在这，项目基本结构不变<br><a href="/2019/04/25/understanding-grid-1/" title="初涉grid布局🐱（一）">初涉grid布局🐱（一）</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.03</span>); </span></span><br><span class="line"><span class="undefined">        border-radius: 3px;</span></span><br><span class="line"><span class="undefined">        font-size: 35px;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ffc600</span>;</span></span><br><span class="line"><span class="undefined">    &#125;		 </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="基于分割线放置单个项目-item"><a href="#基于分割线放置单个项目-item" class="headerlink" title="基于分割线放置单个项目 (item)"></a>基于分割线放置单个项目 (item)</h3><p><code>grid-column-start</code> , <code>grid-column-end</code><br>这两个属性是设置的item上的，不是container上。<br>这两个属性可以指定分割线的数值。</p>
<h4 id="分割线数值"><a href="#分割线数值" class="headerlink" title="分割线数值"></a>分割线数值</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>:<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/understanding-grid-2/E17AAA9F-8B5C-493C-A60F-FE491BABA82D.png">
<p><code>grid-column-start</code> 和 <code>grid-column-end</code>可以缩写为<br><code>grid-column</code><br>grid-column: 1 / -1 表示占据100%的grid的宽度（注意grid的宽度不一定等于容器的宽度哦）</p>
<h4 id="span"><a href="#span" class="headerlink" title="span"></a>span</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/understanding-grid-2/829C3E79-6659-4EEC-988E-473377A81F87.png">
<p>span表示跨度，如上所示，item开始的地方在第二条线上跨度了两个单元。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据规范上所说，个人感觉应该是比如第一个item它是1,2, 但是因为它开始的部分是<code>span 2</code>,所以它的初始位到3了，而此时结束位还在2,根据规范要进行交换。</p>
<blockquote>
<p>If the placement for a grid item contains two lines, and the start line is further end-ward than the end line, swap the two lines. If the start line is equal to the end line, remove the end line.</p>
</blockquote>
<h3 id="自动创建行列填充"><a href="#自动创建行列填充" class="headerlink" title="自动创建行列填充"></a>自动创建行列填充</h3><p>当我们不知道容器宽度的时候想动态的创建 <code>grid-template-columns</code>时可以用 <code>auto-fit</code> 和<code>auto-fill</code>这两个属性。<br><code>grid-template-columns: repeat(auto-fit, 150px);</code><br>不考虑gap的情况下，当容器只有300px的时候就会创建两列，有450px宽的时候就会创建三列。</p>
<p>关于这两个区别可以参考<br><a href="https://css-tricks.com/auto-sizing-columns-css-grid-auto-fill-vs-auto-fit/" target="_blank" rel="noopener">Auto-Sizing Columns in CSS Grid: <code>auto-fill</code> vs <code>auto-fit</code> | CSS-Tricks</a></p>
<h3 id="区域-area"><a href="#区域-area" class="headerlink" title="区域  (area)"></a>区域  (area)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm Sidebar #1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Inventore, sed.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum d<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm Sidebar #2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item footer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm the footer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="undefined">    display: grid;</span></span><br><span class="line"><span class="undefined">    grid-gap: 20px;</span></span><br><span class="line"><span class="undefined">    grid-template-columns: 1fr 10fr 1fr;</span></span><br><span class="line"><span class="undefined">    grid-template-rows: 150px 150px 100px;</span></span><br><span class="line"><span class="undefined">    grid-template-areas:</span></span><br><span class="line"><span class="undefined">      "sidebar-1  content   sidebar-2"</span></span><br><span class="line"><span class="undefined">      "sidebar-1  content   sidebar-2"</span></span><br><span class="line"><span class="undefined">      "footer     footer    ."</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="undefined">    grid-area: footer;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.item1</span> &#123;</span></span><br><span class="line"><span class="undefined">    grid-area: sidebar-1;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.item2</span> &#123;</span></span><br><span class="line"><span class="undefined">    grid-area: content;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.item3</span> &#123;</span></span><br><span class="line"><span class="undefined">    grid-area: sidebar-2;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/understanding-grid-2/C325D24F-B438-4DAA-A85A-BFF466C0687D.png">
<p><code>grid-template-areas</code> 设置对应格子(cell) 的名称，每个名字可以占用多个格子。 “.” 表示死区，footer只用了两个格子，省略不写的话会报错。<br>其中点开 <code>grid-area</code> 会发现<br><img src="/2019/04/25/understanding-grid-2/A23EF2DA-DF01-479E-8109-12930B78689D.png"><br>这里我理解的是各个area所代表的边界。</p>
<h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><h4 id="justify-items-and-align-items"><a href="#justify-items-and-align-items" class="headerlink" title="justify-items and align-items"></a>justify-items and align-items</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/understanding-grid-2/0040FB61-B3E3-4170-9D03-397DBADE1342.png">
<p>如图所示 <code>justify-items</code> 和 <code>align-items</code> 可以将项目在单元格内居中，而且会使得项目的宽度是它本身的宽度，而不会占满单元格。和flex，没有设置<code>align-items</code> 很像，不设置的时候会自动被填满。<br><code>place-items</code> 可以将这两个属性合起来写。</p>
<h4 id="justify-content-and-align-content"><a href="#justify-content-and-align-content" class="headerlink" title="justify-content and align-content"></a>justify-content and align-content</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-content</span>: center;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/understanding-grid-2/71CCF494-7D86-4A85-8B70-E7ADAF011059.png">
<p>如图所示，是将container内部的整体进行居中。</p>
<h4 id="align-self-and-justify-self"><a href="#align-self-and-justify-self" class="headerlink" title="align-self and justify-self"></a>align-self and justify-self</h4><p> <code>justify-items</code> 和 <code>align-items</code> 都是作用于所有的项目上，这个可以设置单个项目的排列方式。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: start;</span><br><span class="line">    <span class="attribute">align-self</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2019/04/25/understanding-grid-2/D22D06E5-690C-4864-B8E8-5B03E38AF291.png">
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">A Complete Guide to Grid | CSS-Tricks</a><br> <a href="https://www.w3.org/TR/css-grid-1/" target="_blank" rel="noopener">https://www.w3.org/TR/css-grid-1/</a> </p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title>初涉grid布局🐱（一）</title>
    <url>/2019/04/25/understanding-grid-1/</url>
    <content><![CDATA[<p>一直觉得grid 是个离我很遥远的技术，以为兼容性差，直到最近查看了 <a href="https://caniuse.com/#search=grid" target="_blank" rel="noopener">https://caniuse.com/#search=grid</a> </p>
<img src="/2019/04/25/understanding-grid-1/CC870F6C-ECE9-4DA6-A367-D31D1B0FC7DB.png">
<p>发现其实兼容性已经很好了，本篇文章基于<a href="https://cssgrid.io/" target="_blank" rel="noopener">Wes Bos的grid课程</a>，以及相关技术文章整理而成。<br>相关属性的取值可能有多个，需要自行查阅文档😯</p>
<h3 id="开发浏览器选择"><a href="#开发浏览器选择" class="headerlink" title="开发浏览器选择"></a>开发浏览器选择</h3><p>推荐使用火狐浏览器开发者版本 <a href="https://www.mozilla.org/en-US/firefox/developer/" target="_blank" rel="noopener">Firefox Developer Edition</a> ，对css grid调试很有帮助，相关好处下文有提到。<br><a id="more"></a></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="容器-grid-container"><a href="#容器-grid-container" class="headerlink" title="容器 (grid container)"></a>容器 (grid container)</h4><p>就是运用<code>display: grid</code>的元素，对其内部的直接子元素进行布局。</p>
<h4 id="项目-grid-item"><a href="#项目-grid-item" class="headerlink" title="项目 (grid item)"></a>项目 (grid item)</h4><p>容器的直接子元素，下面代码中的<code>.item</code> ,不包括 <code>.sub-item</code><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sub-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="分割线-grid-line"><a href="#分割线-grid-line" class="headerlink" title="分割线 (grid line)"></a>分割线 (grid line)</h4><p>分割grid内行和列的线。<br>打开火狐开发者版的开发者工具更直观点。将需要调试的grid 容器勾上，右边勾选上显示分割线数字。<br><img src="/2019/04/25/understanding-grid-1/5CD70B16-D50E-440E-97D3-619D978B1DF2.png"><br>如下图所示可以看到分割线的序号了。</p>
<img src="/2019/04/25/understanding-grid-1/59D74D20-5580-4AE1-8482-FCE7DE810E16.png">
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps: 如果对 <code>fr</code> 有疑问的可以在下文中找到答案，这里只是为了展示火狐的开发者工具。</p>
<h4 id="单元格-grid-cell"><a href="#单元格-grid-cell" class="headerlink" title="单元格 (grid cell)"></a>单元格 (grid cell)</h4><p>上图所示有一行四列。被分割出来4个单元格。</p>
<hr>
<p>正文部分开始，没有申明html 结构的代码部分都是采用以下<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.03</span>); </span></span><br><span class="line"><span class="undefined">        border-radius: 3px;</span></span><br><span class="line"><span class="undefined">        font-size: 35px;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ffc600</span>;</span></span><br><span class="line"><span class="undefined">    &#125;		 </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1、grid-基础"><a href="#1、grid-基础" class="headerlink" title="1、grid 基础"></a>1、grid 基础</h3><img src="/2019/04/25/understanding-grid-1/8CCD3D09-553A-4CC7-8CE7-A057D4DCD8A5.png">
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知识点：</p>
<ol>
<li><code>grid-template-columns</code> 定义列。 <code>grid-template-rows</code> 定义行。<br><code>grid-gap</code> 定义列行之间的间隔。</li>
<li>分割线纵向有3条，横向同样有3条。每条分割线的数字标示可以有正数和负数，-1 表示最后一条线。</li>
<li>4个项目放入grid中的时候会被拉伸放大。当前样式中没有设置.item 的大小，会被自动拉伸。如果设置了大小<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>则如下图所示<br><img src="/2019/04/25/understanding-grid-1/B04A072A-1436-463E-99C0-89B96998928C.png"><br>没有超出容器的范围</p>
<ol start="4">
<li>grid边界在调试工具下是实现。划分行列的线是虚线；gap中填充的是斜线。</li>
<li><code>grid-template-columns: 50px 100px;</code> 和 <code>grid-template-rows: 50px 80px;</code> 可以被简写成 <code>grid-template: 50px 80px/50px 100px;</code></li>
</ol>
<h3 id="2、明确和非明确的grid-explicit-implicit-grid"><a href="#2、明确和非明确的grid-explicit-implicit-grid" class="headerlink" title="2、明确和非明确的grid ( explicit implicit grid )"></a>2、明确和非明确的grid ( explicit implicit grid )</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/04/25/understanding-grid-1/8F27B740-C828-43C6-B2A8-8702CBE1EC34.png">
<ol>
<li>我们用<code>grid-template-columns</code>创建了两列，但是并没有指定行, grid 默认情况下会帮我们创建新的分割线和行。</li>
<li>明确的grid (explicit grid)  e.g. <code>grid-template-columns</code>，<code>grid-template-rows</code> 创建的在开发者工具上是虚线，而非明确创建的看图上1、3，2、4之间的是点线。</li>
<li>自动创建的行的高度是item本身的高度。如果同一行的两个item高度不一致则会采用高度高的item作为当前行的高度。 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item3</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2019/04/25/understanding-grid-1/B7AAF5EE-56E9-4F3C-87B9-EDF3EE9A264B.png">
<ol start="4">
<li><code>grid-auto-rows</code> 可以定义自动添加的row分配的高度<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2019/04/25/understanding-grid-1/3FCE0762-9539-45F6-9277-1BCF011AC720.png">
<p>火狐中目前只能是单个值；谷歌可以是两个值。<br><img src="/2019/04/25/understanding-grid-1/21E91189-4015-48C9-BC32-987767AD451C.png"><br>（火狐）<br><img src="/2019/04/25/understanding-grid-1/ABEAAEE7-96F8-4726-A55E-8472BDDA1A80.png"><br>（谷歌）</p>
<h3 id="3、grid-auto-flow"><a href="#3、grid-auto-flow" class="headerlink" title="3、grid-auto-flow"></a>3、grid-auto-flow</h3><p>默认情况下grid会在当前行放不下新的item时会创建新的行，通过<code>grid-auto-flow: column</code>可以更改这个默认行为。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2019/04/25/understanding-grid-1/05BA7A5B-332D-4004-8520-39459846D31B.png">
<ol>
<li>grid会创建非明确的列，注意看虚线。</li>
<li>创出明确grid的item的宽度在不指定宽度的情况下会均分剩下的空间类似我们即将要介绍的<code>fr</code>单位。自动创建的行的高度是item自身的高，有点像一个div的默认宽度就是容器的宽度，高度是div内容的高度。</li>
<li>可以通过<code>grid-auto-columns</code>指定非明确创立的列。<h3 id="4、设置行、列的大小"><a href="#4、设置行、列的大小" class="headerlink" title="4、设置行、列的大小"></a>4、设置行、列的大小</h3>除了上面设置<code>grid-template-columns: 50px 100px</code> 这种固定大小还有其他单位可以用。<code>auto</code>, <code>fr</code>, <code>%</code>; 甚至还可以应用函数<code>repeat()</code>, <code>minmax()</code><h4 id="百分数"><a href="#百分数" class="headerlink" title="百分数"></a>百分数</h4><code>grid-template-columns: 200px 50%</code><img src="/2019/04/25/understanding-grid-1/FD4BD050-43E9-41A4-AA95-6D38C2DE58A5.png">
如图所示，分成两列第二列的宽度是container宽的50%。如果屏幕宽度再小的话就会出现如下图所示<img src="/2019/04/25/understanding-grid-1/B0E65BAB-D479-4552-924D-C7C3B4391FBF.png">
grid超出了container的范围，再小的话就会出现滚动条了。<h4 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h4>fr是fractional. 可以考虑成free space. 他会将剩下空间进行划分，并且兼顾到grid-gap.有点像flexbox的<code>flex</code>会自动填满剩余空间一样。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2019/04/25/understanding-grid-1/fr.gif">
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>个人总结如下：</p>
<ol>
<li>如果没有fr之类的单位，比如 px auto的组合，auto在这里会扮演类似fr的角色，会自动填充；如果全是auto则类似。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> auto auto;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2019/04/25/understanding-grid-1/E973B318-CBE3-4FB5-B555-D0B847279CFA.png">
<ol start="2">
<li>如果有fr，则auto就是当列最宽的宽度作为列宽。fr负责填充<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr auto;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item4</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2019/04/25/understanding-grid-1/D5965548-1028-4923-8EA9-BE35BE357C47.png">
<ol start="3">
<li>如果item有 min-width的时候，auto列是不会比这个min-width要小的。</li>
</ol>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat ()"></a>repeat ()</h4><p><code>grid-template-columns: 1fr 1fr 1fr</code> 可以写成 <code>grid-tempalte-columns: repeat(3,1fr)</code><br>repeat函数的第二个参数也可以为多个单位。比如 <code>repeat(2,1fr 100px)</code></p>
<h4 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h4><p>表示一个取值范围；<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns </span>: <span class="built_in">minmax</span>(100px, 1fr)  <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果最大值比最小值小的情况下直接返回最小值, 在当前容器是1fr 1fr 1fr且单个fr的值大于100px的时候才会运用fr，其他情况都是100px</p>
<a href="/2019/04/25/understanding-grid-2/" title="初涉grid布局🐱（二）">初涉grid布局🐱（二）</a>]]></content>
      <categories>
        <category>frontend</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title>小白眼中的https👀</title>
    <url>/2019/04/15/understanding-https/</url>
    <content><![CDATA[<h3 id="https的作用"><a href="#https的作用" class="headerlink" title="https的作用"></a>https的作用</h3><p>将SSL引入http，在两个系统（比如客户端和服务端）中可以传输信息的同时保证安全性，即使传输过程中被别人截胡，别人也看不出什么，因为传输的信息都被加密了。</p>
<h4 id="和http的区别"><a href="#和http的区别" class="headerlink" title="和http的区别"></a>和http的区别</h4><ol>
<li>加密和不加密的文本传输</li>
<li>http默认端口80 https默认端口443</li>
<li>网址开头不一样</li>
<li>数据传输更快因为信息被加密后减小了体积<a id="more"></a>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3>对称加密：双方握有同一个key,可以事先双方协定好。这个key可以同时用来加密和解密。</li>
</ol>
<p>非对称加密： 一对🔑，公钥和私钥； 公钥可以解密私钥加密的信息，私钥也可以解密公钥的信息，公钥可以分享给任何人。有的时候比如第一次沟通，双方无法见面的情况下就要用到非对称加密。</p>
<h4 id="举例利用非对称加密客户端到服务端的请求安全。"><a href="#举例利用非对称加密客户端到服务端的请求安全。" class="headerlink" title="举例利用非对称加密客户端到服务端的请求安全。"></a>举例利用非对称加密客户端到服务端的请求安全。</h4><ol>
<li>客户端向服务端发送连接请求。</li>
<li>服务端将公钥发送给客户端，同时保留一份私钥。</li>
<li>客户端收到公钥后将待发送的信息利用公钥加密发给服务端。</li>
<li>服务端利用私钥将客户端发来的信息进行解密。</li>
</ol>
<p>这个过程是为了保证客户端到服务端的信息不被拦截。黑客如果在第三部拦截的话，他没有私钥解密不了信息。但是存在一个问题，如果第二部被黑客拦截了，黑客将自己的公钥发送给客户端，客户端然后就会将自己的信息用黑客的公钥加密发送的时候再被黑客拦截信息就被黑客知道了。</p>
<h3 id="证书的作用"><a href="#证书的作用" class="headerlink" title="证书的作用"></a>证书的作用</h3><p>要能保证我收到的公钥是要能和我想沟通的人对的上。所以就会想到在这个公钥上加上签名，表明这个人的身份。但是就比如说你想和小明沟通上。当你第一次和小明沟通的时候，你无法确认你收到的签名是不是小明签的。</p>
<p>为什么不能确认是小明：小明的签名里说我就是小明。那小黑也可以发个签名说我是小黑。</p>
<p>怎么做：引入第三方机构证明小明就是小明；就好像身份证一样，这是国家机构证明你的个人身份。</p>
<h4 id="伪造证书"><a href="#伪造证书" class="headerlink" title="伪造证书"></a>伪造证书</h4><p>伪造证书本身是不困难；但是浏览器只能信任某些权威机构签发的证书。这些权威机构的算法很复杂，保证了不会被轻易伪造签名。</p>
<h3 id="SSL具体如何工作"><a href="#SSL具体如何工作" class="headerlink" title="SSL具体如何工作"></a>SSL具体如何工作</h3><p>ssl  Secure Socket Layer . 它是一个传输加密的机制，信息在两个系统之间传输时它来保证传输的安全性，比如什么用户信息，银行卡账号密码。<br>ssl通讯主要分为两个步骤</p>
<ol>
<li>ssl 握手</li>
<li>实际数据传输</li>
</ol>
<h4 id="ssl握手"><a href="#ssl握手" class="headerlink" title="ssl握手"></a>ssl握手</h4><p>握手阶段是非对称加密，实际数据传输过程是对称加密。</p>
<ol>
<li>客户端发送客户端的ssl版本号，密码设置(cipher settings)给到服务器</li>
<li>服务器应答服务器的ssl版本号，密码设置。ssl 证书（里面包含有公钥）</li>
<li>客户端在CA处验证ssl证书。验证成功后往下走，验证失败则抛错</li>
<li>客户端创建一个session key。以刚刚验证过的公钥加密发送给服务器。</li>
<li>服务器用对应的私钥解密出session key.并且用session key 加密后的信息告知客户端。 key是用于后续传输数据的对称加密的key。非对称加密的公钥和私钥这个时候就不使用了。</li>
</ol>
<h4 id="实际数据传输"><a href="#实际数据传输" class="headerlink" title="实际数据传输"></a>实际数据传输</h4><p>用上面得到的session key 对称加密进行传输。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p> <a href="https://medium.freecodecamp.org/https-explained-with-carrier-pigeons-7029d2193351" target="_blank" rel="noopener">https://medium.freecodecamp.org/https-explained-with-carrier-pigeons-7029d2193351</a> </p>
<p><a href="https://www.tutorialsteacher.com/https" target="_blank" rel="noopener">Learn Https</a></p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>初探HTTP缓存👀</title>
    <url>/2019/04/15/understand-http-cache/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>浏览器（和代理）利用缓存减少http数量或者是减少相应文件大小，增加页面加载速度。</p>
<h2 id="缓存方法"><a href="#缓存方法" class="headerlink" title="缓存方法"></a>缓存方法</h2><h3 id="expires-header"><a href="#expires-header" class="headerlink" title="expires header"></a>expires header</h3><p> 浏览器会将过期时间和相应的url缓存起来，请求同一个资源时查看是否过期，没有过期就直接从缓存里取出，不用发送请求了。过期之后的策略请看最下面的<strong>缓存有效性确认</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(“Expires”, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">2592000000</span>).toUTCString());</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>优点：<br>没有额外请求 <code>200 OK (from memory cache)</code></p>
<p>缺点：</p>
<ol>
<li>因为是一个具体时间，需要服务端和客服端的时间一致</li>
<li>需要监测这个资源，当时间点到了的时候要更新过期时间</li>
</ol>
<h3 id="Cache-Control-Max-Age"><a href="#Cache-Control-Max-Age" class="headerlink" title="Cache-Control Max-Age"></a>Cache-Control Max-Age</h3><p>使用了偏移时间，应该是把资源创建时间和资源以及偏移时间一起存到缓存里了。每次访问资源的时候，查看资源创建的时间并且加上偏移时间和现在时间进行比较。和<code>Expires</code>一样都是不发送请求了。<br>在自己的电脑上简单测了下，500KB的也可以缓存。<br>同时有<code>Expires</code> 和 <code>Cache-Control</code> 的话后者会覆盖前者<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"public, max-age=2592000"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="server-cache-control"><a href="#server-cache-control" class="headerlink" title="server cache-control"></a>server cache-control</h4><p>上面的是server端的</p>
<h4 id="client-cache-control"><a href="#client-cache-control" class="headerlink" title="client cache-control"></a>client cache-control</h4><p>浏览器会将<code>html</code>文件的请求头里带上<code>Cache-Control:max-age=0</code> 表示即使有缓存，也会重新访问下服务器验证下。server可以根据改变日期(参考最下面的<strong>缓存有效性确认</strong>)可以返回<code>304</code>,这样浏览器就直接用缓存了。</p>
<p>优点：<br>和<code>Expires</code> 一样</p>
<p>缺点：<br><code>http1.1</code>引入，尽管很少量的浏览器仍然使用1.0。 有些插件可以帮助你设置，一种写法同时写<code>Expires</code> 和<code>Cache-Control</code></p>
<h2 id="缓存有效性确认"><a href="#缓存有效性确认" class="headerlink" title="缓存有效性确认"></a>缓存有效性确认</h2><p>过期了会做个一个<strong>conditional get request</strong>(条件GET请求）。如果过期了，会进行有效性检验，如果返回<code>304</code> 则直接拿缓存里的，否则请求新的返回200响应。<br>有两种方法可以查看缓存的有效性</p>
<h3 id="比较最新修改日期"><a href="#比较最新修改日期" class="headerlink" title="比较最新修改日期"></a>比较最新修改日期</h3><p>server: Last-Modified<br>client: If-Modified-Since<br>浏览器将服务器返回的 <code>Last-Modified</code> 的时间和对应资源存入缓存，再请求的时候将这个时间写入请求头的 <code>If-Modified-Since</code> 发送给服务器，服务器判断是否过期，过期则返回200需要重新下载；否则就返回304，无需返回资源所有内容。</p>
<h3 id="ETag-Entity-Tags-实体标签"><a href="#ETag-Entity-Tags-实体标签" class="headerlink" title="ETag (Entity Tags) 实体标签"></a>ETag (Entity Tags) 实体标签</h3><p>类似指纹，可以理解为资源发生变化时，它一定会发生变化。<br>server: ETag<br>client: If-None-Match<br>缺点：做服务器集群时，向不同服务器请求的资源时同一个资源时，可能返回的ETag反而不同，没法充分利用缓存，浪费带宽。《高性能网站建设指南》是不建议使用 <code>Etag</code> 或者要特殊配置 <code>ETag</code> 推荐使用 <code>Last-Modified</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache" target="_blank" rel="noopener">http - What’s the difference between Cache-Control: max-age=0 and no-cache? - Stack Overflow</a></p>
</li>
<li><p>《高性能网站建设指南》</p>
</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag</a></li>
</ol>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解vue的key属性</title>
    <url>/2019/04/12/vue-key/</url>
    <content><![CDATA[<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>如果没有这个属性的时候vue应用 in-place patch（就地复用）策略。列表里的顺序发生改变的时候比如shuffle（列表打乱）的时候，vue为了提升性能，不会移动dom元素，只是更新相应元素的内容节点。</p>
<h3 id="就地复用的弊端"><a href="#就地复用的弊端" class="headerlink" title="就地复用的弊端"></a>就地复用的弊端</h3><blockquote>
<p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</p>
</blockquote>
<a id="more"></a>
<p>如上引用自官网，这个模式就是上面的“就地复用”策略。那么是不是依赖子组件状态的列表渲染采用上面的模式就出问题了呢。如下测试代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item.des &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tweet-component</span>&gt;</span><span class="tag">&lt;/<span class="name">tweet-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">"tweet-component"</span>, &#123;</span></span><br><span class="line"><span class="undefined">    template: `</span></span><br><span class="line"><span class="javascript">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tweet"</span>&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line"><span class="undefined">          &#123;&#123;xixi&#125;&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    `,</span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        xixi: <span class="built_in">Math</span>.random()</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="undefined">      items: [</span></span><br><span class="line"><span class="javascript">        &#123; <span class="attr">title</span>: <span class="string">"nihao1"</span>, <span class="attr">des</span>: <span class="string">"xiexie1"</span> &#125;,</span></span><br><span class="line"><span class="javascript">        &#123; <span class="attr">title</span>: <span class="string">"nihao2"</span>, <span class="attr">des</span>: <span class="string">"xiexie2"</span> &#125;,</span></span><br><span class="line"><span class="javascript">        &#123; <span class="attr">title</span>: <span class="string">"nihao3"</span>, <span class="attr">des</span>: <span class="string">"xiexie3"</span> &#125;</span></span><br><span class="line"><span class="undefined">      ]</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      shuffle() &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// lodash的shuffle方法</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.items = _.shuffle(<span class="keyword">this</span>.items);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>操作如下：</p>
<p>问题出现了：发生变化时，子组件<em>没有更新</em>。<br><img src="/2019/04/12/vue-key/shuffle_array.gif"></p>
<p>ps: 测试临时 DOM 状态 (例如：表单输入值)可以参考这个链接 <a href="https://css-tricks.com/list-rendering-and-vues-v-for-directive/" target="_blank" rel="noopener">List Rendering and Vue’s v-for Directive</a></p>
<h3 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h3><p>这个时候引入 <code>key</code> 就可以解决这个问题。<code>key</code> 的作用是给予一个节点唯一的身份识别，有相同父元素的子元素必须有独特的 <code>key</code> 。这样它可以前后对比，算出哪些节点是要重复使用或者调整顺序。比如原先的 <code>key</code> 的顺序是<code>i1,i2,i3</code>，之后变成了<code>i2,i1,i3</code>这个时候只要i3保持不变，把i2<code>insertBefore</code>到i1节点前就行了（以上是举例，vue具体怎么操作的需要去研究源码）。如果是利用数组的<code>index</code>来作为 <code>key</code> 则两次对比没有区别，就会出现上面动图里出现的子组件没有更新的情况。</p>
<p>可以通过查看下面两个动图查看dom节点的变化。第一个gif是没有使用 <code>key</code> ,第二个是使用了 <code>key</code>。可以看到我点了按钮后，第一个只是更新<code>&lt;p&gt;</code>标签的内容节点。第二个是移动了某一项的<code>&lt;li&gt;</code>标签。<br><img src="/2019/04/12/vue-key/no-key-shuffle.gif"><br><img src="/2019/04/12/vue-key/has-key-shuffle.gif"></p>
<p>ps: 另外可以通过chrome的dom断点功能查看子元素的插入删除。</p>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints#dom" target="_blank" rel="noopener">DOM 更改断点</a></p>
<h3 id="key的其他用途"><a href="#key的其他用途" class="headerlink" title="key的其他用途"></a>key的其他用途</h3><p>key不是只能用在v-for上还可以用在其他元素上。如下代码<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"toggle"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>切换toggle时，它也是切换div。如果你想用上enter/leave animations时，即节点插入和删除的时候的动画时就要打破这个复用，如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"toggle"</span> <span class="attr">key</span>=<span class="string">"1"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"2"</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你的列表不发生变化，或者你只是往列表最后一项添加元素则看似不必要增加<code>key</code>字段。但是你的项目中有很多列表的时候，你有的需要加<code>key</code>，有的不需要加。还不如所有的都加上呢避免别人理解困难(^._.^)ﾉ。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://vuejs.org/v2/guide/list.html#key" target="_blank" rel="noopener">https://vuejs.org/v2/guide/list.html#key</a></p>
<p><a href="https://vuejs.org/v2/api/#key" target="_blank" rel="noopener">https://vuejs.org/v2/api/#key</a></p>
<p><a href="https://forum.vuejs.org/t/simple-clarification-of-when-using-key-with-v-for-is-appropriate-and-why/28966/5" target="_blank" rel="noopener">https://forum.vuejs.org/t/simple-clarification-of-when-using-key-with-v-for-is-appropriate-and-why/28966/5</a></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>framework</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目如何全局引入scss/sass文件</title>
    <url>/2019/04/10/vue-global-sass/</url>
    <content><![CDATA[<p>项目中我们会定义很多全局变量（如下），为了更好的代码复用，避免写面条代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">  - styles</span><br><span class="line">    - _colors.scss</span><br><span class="line">    - _fonts.scss</span><br><span class="line">    - _mixins.scss</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>问题的关键是怎么在我们的项目中引入这些文件。<br><a id="more"></a></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style lang="scss"&gt;</span><br><span class="line">  @<span class="keyword">import</span> <span class="string">"./styles/_colors.scss"</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>在每个单文件组里引入上述代码。这个方法的缺点是，如果更改了文件的位置，你每个组件里的代码都得修改。当然你可以利用 <code>webpack</code> 的 <code>alias</code> 功能写成这种形式  <code>@import &quot;styles/_colors.scss&quot;;</code>  但万一修改了文件名呢，你还是得要一个个修改。其实这不符合<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY</a>原则，没有做好代码复用。</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>可以利用<a href="https://github.com/webpack-contrib/sass-loader#environment-variables" target="_blank" rel="noopener">sass-loader</a> 的一个特性。可以将一段代码插入在每个scss文件头部。</p>
<blockquote>
<p>vue 2.x 配置如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    data: <span class="string">`</span></span><br><span class="line"><span class="string">      @import "@/styles/_colors.scss";</span></span><br><span class="line"><span class="string">      @import "@/styles/_mixins.scss";</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>vue 3.x 配置如下,可以参考 <a href="https://cli.vuejs.org/config/#css-loaderoptions" target="_blank" rel="noopener">vue-cli3配置</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">  loaderOptions: &#123;</span><br><span class="line">    sass: &#123;</span><br><span class="line">      data: <span class="string">`@import "@/styles/_colors.scss";`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>采用第二种方法的时候要注意因为它会在所有 <code>sass</code> 文件里添加相同的代码。如果添加的不是变量, <code>mixin</code> 之类的，而是类似下面的代码的话。假设你有20个scss文件的话，下面这段代码就会出现在你最终打包出来的文件20次。<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p> <a href="https://css-tricks.com/how-to-import-a-sass-file-into-every-vue-component-in-an-app/" target="_blank" rel="noopener">https://css-tricks.com/how-to-import-a-sass-file-into-every-vue-component-in-an-app/</a> </p>
<p> <a href="https://vueschool.io/articles/vuejs-tutorials/globally-load-sass-into-your-vue-js-applications/" target="_blank" rel="noopener">https://vueschool.io/articles/vuejs-tutorials/globally-load-sass-into-your-vue-js-applications/</a> </p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>framework</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
